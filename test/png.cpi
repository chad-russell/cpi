width: i32 = 2880;
height: i32 = 1800;

#import "io";
#import "mem";

#link "libpng";

PNG_LIBPNG_VER_STRING := "1.6.35";
PNG_COLOR_TYPE_RGB: i32 = 2;
PNG_INTERLACE_NONE: i32 = 0;
PNG_COMPRESSION_TYPE_DEFAULT: i32 = 0;
PNG_FILTER_TYPE_DEFAULT: i32 = 0;

type Png none
type PngInfo none

fn png_create_write_struct(ver: *i8, err: *none, err_fn: *none, warn_fn: *none) *Png
fn png_create_info_struct(png: *Png) *PngInfo
fn png_init_io(png: *Png, file: *io.File) none
fn png_set_IHDR(png: *Png, pngInfo: *PngInfo,
                width: i32, height: i32, bitDepth: i32, colorType: i32,
                interlace: i32, compression: i32, filter: i32) none
fn png_write_info(png: *Png, pngInfo: *PngInfo) none
fn png_write_row(png: *Png, row: *i8) none
fn png_write_end(png: *Png, pngInfo: *PngInfo) none



---------------
---- DEMO -----
---------------

#import "iter";

fn error(msg: []i8) {
    io.println(msg);
    panic();
}

type Color struct {
    r: i8,
    g: i8,
    b: i8
}

module random {
    #link "libc";

    fn rand() i32
    fn srand(seed: i32) none
    fn time(timer: *none) i64

    fn seed() {
        srand(cast() time(nil));
    }

    fn fromArray(E := typeof(arr[0]))(arr: []E) {
        return arr[cast() rand() mod arr.count];
    }
}

fn fill_rect(pixels: [][]i8, x: i64, y: i64, w: i64, h: i64, color: Color) {
  for row: iter.range(y, y + h) {
    for col: iter.range(x, x + w) {
        pixels[row][col * 3] = color.r;
        pixels[row][col * 3 + 1] = color.g;
        pixels[row][col * 3 + 2] = color.b;
    }
  }
}

fn write_png_file(filename: []i8) {
  fp := io.fopen(filename|io.cstr, "wb"|io.cstr);
  if fp == nil { error("Failed to open file"); }

  png := png_create_write_struct(PNG_LIBPNG_VER_STRING|io.cstr, nil, nil, nil);
  if png == nil { error("Failed to create png write struct"); }

  info := png_create_info_struct(png);
  if info == nil { error("Failed to create png info struct"); }

  png_init_io(png, fp);

  -- Output is 8bit depth, RGBA format.
  png_set_IHDR(png,
    info,
    width, height,
    8,
    PNG_COLOR_TYPE_RGB,
    PNG_INTERLACE_NONE,
    PNG_COMPRESSION_TYPE_DEFAULT,
    PNG_FILTER_TYPE_DEFAULT);

  png_write_info(png, info);

  background : Color = {54, 110, 122};
  cubeBackground: Color = {35, 49, 62};

  blue: Color = {69, 133, 212};
  red: Color = {239, 41, 35};
  orange: Color = {230, 126, 34};
  yellow: Color = {246, 201, 53};
  green: Color = {57, 202, 116};
  white: Color = {250, 250, 250};

  faceColors := []{blue, red, orange, yellow, green, white};

  -- todo(chad): hack to get around parser issue
  type i8Array []i8

  pixels: [][]i8;
  pixels.count = cast() height;
  pixels.data = mem.alloc!(i8Array)(pixels.count);

  for row: iter.range(0, cast() height) {
    pixelRow: []i8;
    pixelRow.count = 3 * cast(i64) width;
    pixelRow.data = mem.alloc!(i8)(pixelRow.count);
    pixels[row] = pixelRow;
  }

  outerMargin := 25;
  innerMargin := 12;
  miniCubeSize := 138;
  cubeSize := outerMargin * 2 + innerMargin * 2 + miniCubeSize * 3;

  -- background
  fill_rect(pixels, 0, 0, cast() width, cast() height, background);

  cubeX := (cast() width - cubeSize) / 2;
  cubeY := (cast() height - cubeSize) / 2;

  -- cube background
  fill_rect(pixels, cubeX, cubeY, cubeSize, cubeSize, cubeBackground);

  random.seed();

  -- squares
  sqY := cubeY + outerMargin;
  for sqRow: iter.range(0, 3) {
    sqX := cubeX + outerMargin;

    for sqCol: iter.range(0, 3) {
        fill_rect(pixels, sqX, sqY, miniCubeSize, miniCubeSize, random.fromArray(faceColors));
        sqX += miniCubeSize + innerMargin;
    }

    sqY += miniCubeSize + innerMargin;
  }

  for row: iter.range(0, cast() height) {
    png_write_row(png, pixels[row].data);
  }

  png_write_end(png, nil);

  -- cleanup
  for r: pixels {
    mem.free(r.data);
  }
  mem.free(pixels.data);
  io.fclose(fp);
}

fn main() {
  write_png_file("/Users/chadrussell/Pictures/cubeBackground.png");

  return 0;
}