fn foo() {
    ret bar;
}

fn main() {
    f := fn() {
        ret fn() {
            ret foo;
        };
    };

    a1 := f()()()();

    a2 := apply(inc, 1) + apply_overboard(inc, 0);

    a3 := ^^^^^^&&&^&&&&^&^^&&3;

    a4_helper := &&&&^&&&&&&&&&a3;
    a4 := ^^^^^^^^^^^^a4_helper;

    a5 := a5_fn();

    a6 := (^^&&a5_fn)();

    a7 := (^&(fn() i32 { ret 3; }))();

    a8_helper1 := &&bad;
    a8_helper2 := &&bar;
    ^a8_helper1 = ^a8_helper2;
    a8 := (^^a8_helper1)();

    a9 := bad();
    a9_p := &&&a9;
    ^^^a9_p = 3;

    a10 := testStruct1();

    a11 := testStruct2();

    a12 := testAddDots();

    a13 := testParamPass();

    a14 := testNestedFunc();

    a15 := testDotLhs();

    ret a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14;
}

fn testDotLhs() {
    p: point;
    p.x = 3;
    q := &&&&p;
    qq := ^^q;
    qq.x = 3;
    ret q.x;
}

fn testNestedFunc() {
    p: point;
    p.x = 999;
    p.y = 3;

    ret get_y(point_id(point_id(point_id(p))));
}

fn point_id(p: point) {
    ret p;
}

type point struct {
    x: i32,
    y: i32
}

fn testAddDots() {
    p: point;
    p.x = 1;
    p.y = 2;
    q := &&&&&p;
    qq := ^^q;

    ret qq.x + qq.y;
}

fn testParamPass() {
    p: point;
    p.x = 3;
    ret (fn(p: point) { ret p.x; })(p);
}

type S struct {
	x: struct {
		p1: i32,
		p2: i32
	},
	y: i32
}

fn testStruct1() {
	f: S;
	f.y = 3;
	ret ^^&&(f.y);
}

fn testStruct2() {
	f: S;
	f.y = 3;
	ret f.y;
}

fn bad() i32 { ret 999; }

fn a5_fn() {
    f := fn() i32 { ret 3; };
    p := &f;
    ret (^p)();
}

fn bar() i32 {
    ret 3;
}

fn inc(n: i32) {
    ret n + 1;
}

fn apply(a: fn(n: i32) i32, b: i32) {
    ret a(b);
}

fn apply_overboard(a: fn(n: i32) i32, b: i32) {
    ret fn(f: fn(n: i32) i32, g: i32) {
        ret f(g);
    }(a, b);
}

fn get_x(p: point) {
    ret p.x;
}

fn get_y(p: point) {
    ret p.y;
}
