type ParamData struct {
    name:  []i8,
    _type: *TypeInfo
}

type StructData struct {
    params: []ParamData
}

type EnumData struct {
    params: []ParamData
}

type FnData struct {
    params:     []ParamData,
    returnType: *TypeInfo
}

type PointerData struct {
    underlyingType: *TypeInfo
}

type ArrayData struct {
    elementType: *TypeInfo
}

type TypeInfo union {
    NONE:             none,
    INT_LITERAL:      i64,
    I8:               none,
    I32:              none,
    I64:              none,
    FLOAT_LITERAL:    f64,
    BOOLEAN:          none,
    BOOLEAN_LITERAL:  bool,
    F32:              none,
    F64:              none,
    FN:               FnData,
    STRUCT:           StructData,
    POINTER:          PointerData,
    ENUM:             EnumData,
    ARRAY:            ArrayData,
}

type Any struct {
    _type:  TypeInfo,
    value:  *none
}

fn printTypeInfo(t: *TypeInfo) {
    if tagcheck(t.STRUCT) {
        puts("struct{");
        for param : t.STRUCT.params {
            puts(param.name);
            puts(": ");
            printTypeInfo(param._type);
            puts(", ");
        }
        puts("}");
    }
    else if tagcheck(t.INT_LITERAL) {
        puts("i32");
    }
}

fn printType( T := typeof(t) )(t: T) {
    printTypeInfo(&typeinfo(t));
}

fn main() {
    printType({x: 3, y: 4});
}

fn println(s: []i8) {
    puts(s); puts("\n");
}

fn assert(b: bool) {
    if b == false { panic(); }
}
