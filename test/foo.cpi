#import "sdl";
#import "buffer";
#import "printing": p;
#import "io";
#import "mem";

#link "libfoo";
fn toDouble(n: i32) f64
fn toInt(n: f64) i32
fn i32ToI64(n: i32) i64

module cairo {
    #link "libcairo";

    FORMAT_INVALID: i32   = -1;
    FORMAT_ARGB32: i32    = 0;
    FORMAT_RGB24: i32     = 1;
    FORMAT_A8: i32        = 2;
    FORMAT_A1: i32        = 3;
    FORMAT_RGB16_565: i32 = 4;
    FORMAT_RGB30: i32     = 5;

    type FontFace none
    type Surface none
    type Context none

    type Glyph struct {
        index: i64,
        x: f64,
        y: f64
    }

    fn cairo_ft_font_face_create_for_ft_face(face: ft.Face, loadFlags: i32) *FontFace
    fn cairo_image_surface_create_for_data(data: *i8, format: i32, width: i32, height: i32, stride: i32) *Surface
    fn cairo_surface_set_device_scale(surface: *Surface, xScale: f64, yScale: f64) none
    fn cairo_create(surface: *Surface) *Context
    fn cairo_set_source_rgba(context: *Context, r: f64, g: f64, b: f64, a: f64) none
    fn cairo_set_font_face(context: *Context, face: *FontFace) none
    fn cairo_set_font_size(context: *Context, ptSize: f64) none
    fn cairo_surface_destroy(surface: *Surface) none
    fn cairo_destroy(context: *Context) none
    fn cairo_font_face_destroy(face: *FontFace) none
    fn cairo_glyph_allocate(glyphCount: i32) *Glyph
    fn cairo_show_glyphs(cr: *Context, glyphs: *Glyph, numGlyphs: i32) none
}

module hb {
    #link "libharfbuzz";

    type Blob none
    type Font none
    type Face none
    type Buffer none
    type Language *none

    type Feature struct {
        tag: i32,
        value: i32,
        start: i32,
        end: i32,
    }

    type GlyphInfo struct {
        codepoint: i32,
        mask: i32,
        cluster: i32,
        var1: i32,
        var2: i32
    }

    type GlyphPosition struct {
        xAdvance: i32,
        yAdvance: i32,
        xOffset: i32,
        yOffset: i32,
        var: i32
    }

    HB_DIRECTION_LTR: i32 = 4;
    HB_SCRIPT_COMMON: i32 = 1517910393;

    fn hb_blob_create_from_file(fileName: *i8) *Blob
    fn hb_face_create(blob: *Blob, index: i32) *Face
    fn hb_font_create(face: *Face) *Font
    fn hb_ot_font_set_funcs(font: *Font) none
    fn hb_font_set_scale(font: *Font, xScale: i32, yScale: i32) none
    fn hb_font_destroy(font: *Font) none
    fn hb_buffer_create() *Buffer
    fn hb_buffer_set_direction(buf: *Buffer, direction: i32) none
    fn hb_buffer_set_script(buf: *Buffer, script: i32) none
    fn hb_buffer_set_language(buf: *Buffer, language: Language) none
    fn hb_language_get_default() Language
    fn hb_buffer_add_utf8(buffer: *Buffer, text: *i8, textLength: i32, itemOffset: i32, itemLength: i32) none
    fn hb_shape(font: *Font, buffer: *Buffer, features: *Feature, numFeatures: i32) none
    fn hb_buffer_get_length(buf: *Buffer) i32
    fn hb_buffer_get_glyph_infos(buf: *Buffer, length: *i32) *GlyphInfo
    fn hb_buffer_get_glyph_positions(buf: *Buffer, length: *i32) *GlyphPosition
}

module ft {
    #link "libfreetype";

    type Library *none
    type Face *none

    fn FT_Init_FreeType(library: *Library) i32
    fn FT_New_Face(library: Library, filePath: *i8, faceIndex: i64, face: *Face) i32
}

WIDTH: i32 = 200;
HEIGHT: i32 = 100;
FONT_SIZE: i32 = 18;

type TextContext struct {
    hbFont: *hb.Font,

    cairoFont: *cairo.FontFace,
    cairoGlyphs: *cairo.Glyph,
    cairoSurface: *cairo.Surface,
    cairoContext: *cairo.Context,

    font: *i8,
    text: *i8,

    done: bool,

    sdlWindow: *sdl.Window,
    sdlSurface: *sdl.Surface,
    sdlRenderer: *sdl.Renderer
}

fn loadFonts(tctx: *TextContext) {
    tctx.font = "/System/Library/Fonts/Apple Color Emoji.ttc"|io.cstr;
    -- tctx.font = "/Users/chadrussell/Projects/text/Noto-unhinted/NotoColorEmoji.ttf"|io.cstr;
    tctx.text = "ðŸ™ˆ ðŸ‡¹ðŸ‡©"|io.cstr;

    -- tctx.font = "/Users/chadrussell/Library/Fonts/Roboto-Light.ttf"|io.cstr;
    -- tctx.font = "/Library/Fonts/Inconsolata.otf"|io.cstr;
    -- tctx.text = ":)"|io.cstr;

    -- For CAIRO, load using FreeType
    ftLibrary: ft.Library;
    ft.FT_Init_FreeType(&ftLibrary);
    ftFace: ft.Face;
    err := ft.FT_New_Face(ftLibrary, tctx.font, 0, &ftFace);
    if err != 0 {
        p.println("error creating freetype font face");
        panic();
    }
    tctx.cairoFont = cairo.cairo_ft_font_face_create_for_ft_face(ftFace, 0);

    -- For Harfbuzz, load using OpenType (HarfBuzz FT does not support bitmap font)
    blob := hb.hb_blob_create_from_file(tctx.font);
    face := hb.hb_face_create(blob, 0);
    tctx.hbFont = hb.hb_font_create(face);
    hb.hb_ot_font_set_funcs(tctx.hbFont);
    hb.hb_font_set_scale(tctx.hbFont, FONT_SIZE * 64, FONT_SIZE * 64);
}

fn initCairo1(tctx: *TextContext) {
    sdlRenderFlags: i32 = 6;
    tctx.sdlRenderer = sdl.SDL_CreateRenderer(tctx.sdlWindow, -1, sdlRenderFlags);

    -- Compute screen resolution
    -- For instance, on a retina screen, renderer size is twice as window size
    windowWidth: i32;
    windowHeight: i32;
    sdl.SDL_GetWindowSize(tctx.sdlWindow, &windowWidth, &windowHeight);

    rendererWidth: i32;
    rendererHeight: i32;
    sdl.SDL_GetRendererOutputSize(tctx.sdlRenderer, &rendererWidth, &rendererHeight);

    -- Create a SDL surface for Cairo to render onto
    tctx.sdlSurface = sdl.SDL_CreateRGBSurface(
            0,
            rendererWidth,
            rendererHeight,
            32,
            0x00ff0000,
            0x0000ff00,
            0x000000ff,
            0
    );

    -- Get Cairo surface form SDL2 surface
    tctx.cairoSurface = cairo.cairo_image_surface_create_for_data(
            cast(*i8) tctx.sdlSurface.pixels,
            cairo.FORMAT_RGB24,
            tctx.sdlSurface.w,
            tctx.sdlSurface.h,
            tctx.sdlSurface.pitch);

    cairoX_Multiplier := rendererWidth / windowWidth;
    cairoY_Multiplier := rendererHeight / windowHeight;

    -- Scale cairo to use screen resolution
    cairo.cairo_surface_set_device_scale(tctx.cairoSurface, toDouble(cairoX_Multiplier), toDouble(cairoY_Multiplier));

    -- Get Cairo context from Cairo surface
    tctx.cairoContext = cairo.cairo_create(tctx.cairoSurface);
    cairo.cairo_set_source_rgba(tctx.cairoContext, 0.0, 0.0, 0.0, 1.0);
    cairo.cairo_set_font_face(tctx.cairoContext, tctx.cairoFont);
    cairo.cairo_set_font_size(tctx.cairoContext, toDouble(FONT_SIZE));
}

fn drawText(tctx: *TextContext) {
    -- Create  HarfBuzz buffer
    buf := hb.hb_buffer_create();

    -- Set buffer to LTR direction, common script and default language
    hb.hb_buffer_set_direction(buf, hb.HB_DIRECTION_LTR);
    hb.hb_buffer_set_script(buf, hb.HB_SCRIPT_COMMON);
    hb.hb_buffer_set_language(buf, hb.hb_language_get_default());

    -- Add text and lay it out
    hb.hb_buffer_add_utf8(buf, tctx.text, -1, 0, -1);
    hb.hb_shape(tctx.hbFont, buf, nil, 0);

    -- Get buffer data
    glyphCount := hb.hb_buffer_get_length(buf);
    glyphInfo := hb.hb_buffer_get_glyph_infos(buf, nil);
    glyphPos := hb.hb_buffer_get_glyph_positions(buf, nil);

    ithGlyphPos := glyphPos;

    stringWidthInPixels := 0.0;
    i := 0;
    while i < glyphCount {
        stringWidthInPixels = stringWidthInPixels + toDouble(ithGlyphPos.xAdvance) / 64.0;
        ithGlyphPos = ithGlyphPos + 1;
        i = i + 1;
    }

    -- Shape glyph for Cairo
    tctx.cairoGlyphs = cairo.cairo_glyph_allocate(glyphCount);

    x: i32 = 0;
    y: i32 = 0;
    ithGlyphPos = glyphPos;
    ithCairoGlyph := tctx.cairoGlyphs;
    ithGlyphInfo := glyphInfo;

    i = 0;
    while i < glyphCount {
        ithCairoGlyph.index = i32ToI64(ithGlyphInfo.codepoint);
        ithCairoGlyph.x = toDouble(x) + toDouble(ithGlyphPos.xOffset) / 64.0;
        ithCairoGlyph.y = -(toDouble(y) + toDouble(ithGlyphPos.yOffset) / 64.0);
        x = x + toInt(toDouble(ithGlyphPos.xAdvance) / 64.0);
        y = y + toInt(toDouble(ithGlyphPos.yAdvance) / 64.0);

        ithGlyphPos = ithGlyphPos + 1;
        ithCairoGlyph = ithCairoGlyph + 1;
        ithGlyphInfo = ithGlyphInfo + 1;
        i = i + 1;
    }

    -- Move glyph to be on window middle
    ithCairoGlyph = tctx.cairoGlyphs;

    i = 0;
    while i < glyphCount {
        ithCairoGlyph.x = ithCairoGlyph.x + toDouble(WIDTH) / 2 - stringWidthInPixels / 2;
        ithCairoGlyph.y = ithCairoGlyph.y + toDouble(HEIGHT) / 2;

        ithCairoGlyph = ithCairoGlyph + 1;
        i = i + 1;
    }

    -- Fill background in white
    sdl.SDL_FillRect(tctx.sdlSurface, nil, sdl.SDL_MapRGB(tctx.sdlSurface.format, 255, 255, 255));

    -- Render glyph onto cairo context (which render onto SDL2 surface)
    cairo.cairo_show_glyphs(tctx.cairoContext, tctx.cairoGlyphs, glyphCount);

    -- Render SDL2 surface onto SDL2 renderer
    texture := sdl.SDL_CreateTextureFromSurface(tctx.sdlRenderer, tctx.sdlSurface);
    sdl.SDL_RenderCopy(tctx.sdlRenderer, texture, nil, nil);
    sdl.SDL_RenderPresent(tctx.sdlRenderer);
}

fn initSdl(tctx: *TextContext) {
    err := sdl.SDL_Init(sdl.INIT_VIDEO);
    if err != 0 {
        p.println("failed to init SDL");
        panic();
    }

    window := sdl.SDL_CreateWindow("text"|io.cstr,
        sdl.WINDOWPOS_UNDEFINED, sdl.WINDOWPOS_UNDEFINED,
        WIDTH, HEIGHT,
        8196);
    if window == nil {
        p.println("failed to create window");
        panic();
    }

    tctx.sdlWindow = window;
}

fn freeStuff(tctx: *TextContext) {
    mem.free(tctx.cairoGlyphs);
    cairo.cairo_surface_destroy(tctx.cairoSurface);
    cairo.cairo_destroy(tctx.cairoContext);
    cairo.cairo_font_face_destroy(tctx.cairoFont);
    hb.hb_font_destroy(tctx.hbFont);
    sdl.SDL_FreeSurface(tctx.sdlSurface);
    sdl.SDL_Quit();
}

fn main() {
    tctx: TextContext;
    tctx.done = false;

    initSdl(&tctx);

    loadFonts(&tctx);
    initCairo1(&tctx);

    while !tctx.done {
        event: sdl.KeyboardEvent;

        while sdl.SDL_PollEvent(&event) != 0 {
            if event._type == sdl.QUIT {
                tctx.done = true;
            }

            drawText(&tctx);
        }
    }

    return 0;
}
