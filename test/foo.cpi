type ParamData struct {
    name:  []i8,
    _type: *TypeInfo
}

type StructData struct {
    params: []ParamData
}

type EnumData struct {
    params: []ParamData
}

type FnData struct {
    params:     []ParamData,
    returnType: *TypeInfo
}

type PointerData struct {
    underlyingType: *TypeInfo
}

type ArrayData struct {
    elementType: *TypeInfo
}

type TypeInfo enum {
    NONE:             none,
    INT_LITERAL:      i64,
    I8:               none,
    I32:              none,
    I64:              none,
    FLOAT_LITERAL:    f64,
    BOOLEAN:          none,
    BOOLEAN_LITERAL:  bool,
    F32:              none,
    F64:              none,
    FN:               FnData,
    STRUCT:           StructData,
    POINTER:          *TypeInfo,
    ENUM:             EnumData,
    ARRAY:            ArrayData,
}

type Any struct {
    _type:  TypeInfo,
    value:  *none
}

fn printParams(params: []ParamData) {
    for param : params {
        puts(param.name);
        puts(": ");
        printTypeInfo(param._type);
        puts(", ");
    }
}

fn printTypeInfo(t: *TypeInfo) {
    if tagcheck(t.STRUCT) {
        puts("struct{");
        printParams(t.STRUCT.params);
        puts("}");
    }
    else if tagcheck(t.ENUM) {
        puts("enum{");
        printParams(t.ENUM.params);
        puts("}");
    }
    else if tagcheck(t.ARRAY) {
        puts("[]");
        printTypeInfo(t.ARRAY.elementType);
    }
    else if tagcheck(t.NONE) {
        puts("none");
    }
    else if tagcheck(t.INT_LITERAL) {
        puts("int");
    }
    else if tagcheck(t.I8) {
        puts("i8");
    }
    else if tagcheck(t.I32) {
        puts("i32");
    }
    else if tagcheck(t.I64) {
        puts("i64");
    }
    else if tagcheck(t.FLOAT_LITERAL) {
        puts("float");
    }
    else if tagcheck(t.BOOLEAN) {
        puts("boolean");
    }
    else if tagcheck(t.BOOLEAN_LITERAL) {
        if t.BOOLEAN_LITERAL { puts("true"); }
        else { puts("false"); }
    }
    else if tagcheck(t.F32) {
        puts("f32");
    }
    else if tagcheck(t.F64) {
        puts("f64");
    }
    else if tagcheck(t.FN) {
        puts("fn(");
        printParams(t.FN.params);
        puts(") ");
        printTypeInfo(t.FN.returnType);
    }
    else if tagcheck(t.POINTER) {
        puts("*");
        printTypeInfo(t.POINTER);
    }
}

fn printTypeInfoSimple(t: TypeInfo) {
    if tagcheck(t.POINTER) {
        puts("*");
        printTypeInfoSimple(^t.POINTER);
    }
    else {
        puts("other");
    }
}

fn printType( T := typeof(t) )(t: T) {
    printTypeInfo(&typeinfo(t));
}

type linkedList struct {
    value: i32,
    next: *none
}

fn main() {
    type TypeInfoS enum {
        I32: none,
        I64: none
    }

    type Any struct {
        _type:  TypeInfoS
    }

    a : Any = {
        _type: {
            I64: {}
        }
    };

    -- assert(a._type.STRUCT.params[0]._type.tag == 3);
    -- assert(a._type.STRUCT.params[0].name[3] == "duck"[3]);

    return a._type.tag;
}

fn println(s: []i8) {
    puts(s); puts("\n");
}

fn assert(b: bool) {
    if b == false { panic(); }
}
