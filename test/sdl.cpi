#link "libsdl2";
#import "io";

INIT_EVERYTHING: i32 = 29233;
INIT_VIDEO: i32 = 20;
QUIT: i32 = 256;

KEYDOWN: i32 = 0x300;
MOUSEMOTION: i32 = 0x400;
MOUSEBUTTONDOWN: i32 = 0x401;
MOUSEBUTTONUP: i32 = 0x402;

WINDOWPOS_UNDEFINED: i32 = 536805376;
WINDOW_SHOWN: i32 = 0x00000004;
WINDOW_ALLOW_HIGHDPI: i32 = 0x00002000;

type Key enum(i32) {
    a: 4,
    b: 5,
    c: 6,
    d: 7,
    e: 8,
    f: 9,
    g: 10,
    h: 11,
    i: 12,
    j: 13,
    k: 14,
    l: 15,
    m: 16,
    n: 17,
    o: 18,
    p: 19,
    q: 20,
    r: 21,
    s: 22,
    t: 23,
    u: 24,
    v: 25,
    w: 26,
    x: 27,
    y: 28,
    z: 29,

    ENTER: 40,
    BACKSPACE: 42,
    SPACE: 44,

    `,`: 54,
    `.`: 55,

    RIGHT: 79,
    LEFT: 80,
    DOWN: 81,
    UP: 82,

    SHIFT: 225,
}

#impl fn isalpha(key: Key) {
    ckey := cast(i32) key;

    return (ckey >= 4 and ckey <= 29)
        or (ckey >= 54 and ckey <= 55);
}

#impl fn charsFor(key: Key) *i8 {
    -- todo(chad): should be able to do #for here...
    for f: #fieldsof(Key) {
        if f.value == cast(i32) key {
            return f.name|io.cstr;
        }
    }

    return "\0".data;
}

fn SDL_Init(flags: i32) i32
fn SDL_CreateWindow(name: *i8, x: i32, y: i32, w: i32, h: i32, flags: i32) *Window
fn SDL_CreateRenderer(window: *Window, index: i32, flags: i32) *Renderer
fn SDL_RenderSetLogicalSize(renderer: *Renderer, width: i32, height: i32) none
fn SDL_SetRenderDrawColor(renderer: *Renderer, r: i8, g: i8, b: i8, a: i8) none
fn SDL_PollEvent(event: *Event) i32
fn SDL_RenderClear(renderer: *Renderer) none
fn SDL_RenderFillRect(renderer: *Renderer, playerPos: *Rect) none
fn SDL_RenderPresent(renderer: *Renderer) none
fn SDL_GetWindowSize(window: *Window, windowWidth: *i32, windowHeight: *i32) none
fn SDL_GetRendererOutputSize(renderer: *Renderer, rendererWidth: *i32, rendererHeight: *i32) none
fn SDL_CreateRGBSurface(flags: i32, width: i32, height: i32, depth: i32, Rmask: i32, Gmask: i32, Bmask: i32, Amask: i32) *Surface
fn SDL_Quit() none
fn SDL_FreeSurface(surface: *Surface) none
fn SDL_FillRect(surface: *Surface, rect: *Rect, color: i32) i32
fn SDL_MapRGB(format: *PixelFormat, r: i8, g: i8, b: i8) i32
fn SDL_CreateTextureFromSurface(renderer: *Renderer, surface: *Surface) *Texture
fn SDL_RenderCopy(renderer: *Renderer, texture: *Texture, srcRect: *Rect, dstRect: *Rect) i32
fn SDL_GetMouseState(x: *i32, y: *i32) u32

type Window none
type Renderer none
type BlitMap none
type Texture none

type Color struct {
    r: i8,
    g: i8,
    b: i8,
    a: i8,
}

type Palette struct {
    ncolors: i32,
    colors: *Color,
    version: i32,
    refcount: i32
}

type Pallette struct {
    ncolors: i32,
    colors: *Color,
    version: i32,
    refcount: i32
}

type PixelFormat struct {
    format: i32,
    pallette: *Palette,
    BitsPerPixel: i8,
    BytesPerPixel: i8,
    padding: i16,
    Rmask: i32,
    Gmask: i32,
    Bmask: i32,
    Amask: i32,
    Rloss: i8,
    Gloss: i8,
    Bloss: i8,
    Aloss: i8,
    Rshift: i8,
    Gshift: i8,
    Bshift: i8,
    Ashift: i8,
    refcount: i32,
    next: *PixelFormat
}

type Rect struct {
    x: i32, y: i32,
    w: i32, h: i32
}

type Surface struct {
    flags: i32,
    format: *PixelFormat,
    w: i32, h: i32,
    pitch: i32,
    pixels: *none,
    userdata: *none,
    locked: i32,
    lockData: *none,
    clipRect: Rect,
    map: *BlitMap,
    refcount: i32
}

type Event struct {
    _type: i32,

    data: struct {
        event: KeyboardEvent,
    }
}

type MouseMotionEvent struct {
    _type: i32,
    timestamp: u32,
    windowID: u32,
    which: u32,
    state: u32,
    x: i32,
    y: i32,
    xrel: i32,
    yrel: i32
}

type MouseButtonEvent struct {
    _type: i32,
    timestamp: u32,
    windowID: u32,
    which: u32,
    button: u8,
    state: u8,
    clicks: u8,
    padding1: u8,
    x: i32,
    y: i32
}

type KeyboardEvent struct {
    _type: i32,
    timestamp: i32,
    windowId: i32,
    state: i8,
    repeat: i8,
    padding2: i8,
    padding3: i8,
    keysym: Keysym
}

type Keysym struct {
    scancode: Key,
    sym: i32,
    mod1: i8,
    mod2: i8,
    unused: i32
}

fn demoGame() {
    winX: i32 = 100;
    winY: i32 = 200;
    sizeX: i32 = 300;
    sizeY: i32 = 400;

    SDL_Init(INIT_EVERYTHING);
    window := SDL_CreateWindow(cast(*i8) "foo\0".data, winX, winY, sizeX, sizeY, cast(i32) 0);
    renderer := SDL_CreateRenderer(window, cast(i32) -1, cast(i32) 0);

    SDL_RenderSetLogicalSize(renderer, sizeX, sizeY);
    SDL_SetRenderDrawColor(renderer, 0, 255, 50, 255);

    playerPos: Rect;
    playerPos.x = 20;
    playerPos.y = 20;
    playerPos.w = 50;
    playerPos.h = 20;

    keydown := 0;

    loop := true;
    while loop
    {
        event: Event;
        while SDL_PollEvent(&event) != 0
        {
            if event._type == QUIT {
                loop = false;
            }
            else if event._type == KEYDOWN
            {
                keyboardEvent := cast(KeyboardEvent) event;

                if keyboardEvent.keysym.scancode == Key.RIGHT {
                    playerPos.x += 10;
                }
                else if keyboardEvent.keysym.scancode == Key.LEFT {
                    playerPos.x -= 10;
                }
                else if keyboardEvent.keysym.scancode == Key.UP {
                    playerPos.y -= 10;
                }
                else if keyboardEvent.keysym.scancode == Key.DOWN {
                    playerPos.y += 10;
                }

                keydown += 1;
            }

            SDL_RenderClear(renderer);
            SDL_SetRenderDrawColor(renderer, 100, 140, 255, 255);
            SDL_RenderFillRect(renderer, &playerPos);
            SDL_SetRenderDrawColor(renderer, 155, 225, 155, 255);
            SDL_RenderPresent(renderer);
        }
    }

    return keydown;
}
