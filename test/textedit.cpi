#import "sdl";
#import "buffer": buf;
#import "io";
#import "mem";
#import "cairo";
#import "harfbuzz": hb;
#import "freetype": ft;
#import "iter";
#import "optional";
#import "se";

WIDTH     : i32 = 800;
HEIGHT    : i32 = 350;
FONT_SIZE : i32 = 20;

type CachedGlyph struct {
    codepoint: i32,
    extents: cairo.GlyphExtents,
    pattern: *cairo.Pattern
}

type TextContext struct {
    hbFont: *hb.Font,
    hbBuffer: *hb.Buffer = nil,

    cairoFont: *cairo.FontFace,
    cairoSurface: *cairo.Surface,
    cairoContext: *cairo.Context,

    font: []i8,
    eb: se.EditorBuffer,

    glyphCache: buf.Buffer!(CachedGlyph),

    done := false,

    sdlWindow: *sdl.Window,
    sdlSurface: *sdl.Surface,
    sdlRenderer: *sdl.Renderer,

    windowWidth: i32,
    windowHeight: i32,

    rendererWidth: i32,
    rendererHeight: i32,

    xScale: f64,
    yScale: f64
}

fn loadFonts(tctx: *TextContext) {
    -- tctx.font = "/System/Library/Fonts/Apple Color Emoji.ttc";
    -- tctx.font = "/Users/chadrussell/Projects/text/Noto-unhinted/NotoColorEmoji.ttf";
    -- tctx.font = "/Users/chadrussell/Projects/text/emojione-apple.ttc";
    -- tctx.font = "/Users/chadrussell/Library/Fonts/Roboto-Light.ttf";
    tctx.font = "/Library/Fonts/Inconsolata.otf";
    -- tctx.font = "/Users/chadrussell/Projects/text/JFWilwod.ttf";

    -- tctx.text = buf.from("Hello");
    -- tctx.text = buf.from("ðŸ™ˆ");

    -- For CAIRO, load using FreeType
    ftLibrary: ft.Library;
    ft.FT_Init_FreeType(&ftLibrary);
    ftFace: ft.Face;
    err := ft.FT_New_Face(ftLibrary, tctx.font|io.cstr, 0, &ftFace);
    if err != 0 {
        io.println("error creating freetype font face");
        panic();
    }
    tctx.cairoFont = cairo.cairo_ft_font_face_create_for_ft_face(ftFace, 0);

    -- For Harfbuzz, load using OpenType (HarfBuzz FT does not support bitmap font)
    blob := hb.hb_blob_create_from_file(tctx.font|io.cstr);
    face := hb.hb_face_create(blob, 0);
    tctx.hbFont = hb.hb_font_create(face);
    hb.hb_ot_font_set_funcs(tctx.hbFont);
    hb.hb_font_set_scale(tctx.hbFont, FONT_SIZE * 64, FONT_SIZE * 64);

    tctx.hbBuffer = hb.hb_buffer_create();
}

fn initCairo(tctx: *TextContext) {
    sdlRenderFlags: i32 = 6;
    tctx.sdlRenderer = sdl.SDL_CreateRenderer(tctx.sdlWindow, -1, sdlRenderFlags);

    -- Compute screen resolution
    -- For instance, on a retina screen, renderer size is twice as window size
    sdl.SDL_GetWindowSize(tctx.sdlWindow, &tctx.windowWidth, &tctx.windowHeight);

    sdl.SDL_GetRendererOutputSize(tctx.sdlRenderer, &tctx.rendererWidth, &tctx.rendererHeight);

    -- Create a SDL surface for Cairo to render onto
    tctx.sdlSurface = sdl.SDL_CreateRGBSurface(
            0,
            tctx.rendererWidth,
            tctx.rendererHeight,
            32,
            0x00ff0000,
            0x0000ff00,
            0x000000ff,
            0
    );

    -- Get Cairo surface form SDL2 surface
    tctx.cairoSurface = cairo.cairo_image_surface_create_for_data(
            cast() tctx.sdlSurface.pixels,
            cairo.FORMAT_RGB24,
            tctx.sdlSurface.w,
            tctx.sdlSurface.h,
            tctx.sdlSurface.pitch);

    tctx.xScale = cast(f64) tctx.rendererWidth / cast(f64) tctx.windowWidth;
    tctx.yScale = cast(f64) tctx.rendererHeight / cast(f64) tctx.windowHeight;

    -- Scale cairo to use screen resolution
    cairo.cairo_surface_set_device_scale(tctx.cairoSurface, tctx.xScale, tctx.yScale);

    -- Get Cairo context from Cairo surface
    tctx.cairoContext = cairo.cairo_create(tctx.cairoSurface);
    cairo.cairo_set_antialias(tctx.cairoContext, cairo.Antialias.SUBPIXEL);
    cairo.cairo_set_source_rgba(tctx.cairoContext, 0.0, 0.0, 0.0, 1.0);
    cairo.cairo_set_font_face(tctx.cairoContext, tctx.cairoFont);
    cairo.cairo_set_font_size(tctx.cairoContext, cast() FONT_SIZE);

    tctx.glyphCache = buf.make!(CachedGlyph)();
}

fn clear(tctx: *TextContext) {
    -- Fill background
    cairo.cairo_save(tctx.cairoContext);
    cairo.cairo_set_source_rgb(tctx.cairoContext, 0.1739, 0.1867, 0.1433);
    cairo.cairo_rectangle(tctx.cairoContext,
        0, 0,
        cast() cairo.cairo_image_surface_get_width(tctx.cairoSurface), cast() cairo.cairo_image_surface_get_height(tctx.cairoSurface));
    cairo.cairo_fill(tctx.cairoContext);
    cairo.cairo_restore(tctx.cairoContext);
}

fn commit(tctx: *TextContext) {
    -- Render SDL2 surface onto SDL2 renderer
    texture := sdl.SDL_CreateTextureFromSurface(tctx.sdlRenderer, tctx.sdlSurface);
    sdl.SDL_RenderCopy(tctx.sdlRenderer, texture, nil, nil);
    sdl.SDL_RenderPresent(tctx.sdlRenderer);
}

fn findGlyph(tctx: *TextContext, codepoint: i32) CachedGlyph {
    for g: tctx.glyphCache.buf {
        if g.codepoint == codepoint {
            return g;
        }
    }

    return cacheGlyph(tctx, codepoint);
}

fn cacheGlyph(tctx: *TextContext, codepoint: i32) {
    cairoGlyph := cairo.cairo_glyph_allocate(1);
    defer { cairo.cairo_glyph_free(cairoGlyph); }

    cairoGlyph.index = cast() codepoint;
    cairoGlyph.x = 0;
    cairoGlyph.y = 0;

    cached: CachedGlyph;
    cached.codepoint = codepoint;

    glyphSurface := cairo.cairo_image_surface_create(
            cairo.FORMAT_RGB24,
            cast() 500,
            cast() 500);
    cached.pattern = cairo.cairo_pattern_create_for_surface(glyphSurface);

    -- Scale cairo to use screen resolution
    xScale: f64;
    yScale: f64;
    cairo.cairo_surface_get_device_scale(tctx.cairoSurface, &xScale, &yScale);
    cairo.cairo_surface_set_device_scale(glyphSurface, xScale, yScale);

    -- Get Cairo context from Cairo surface
    glyphContext := cairo.cairo_create(glyphSurface);

    cairo.cairo_set_font_face(glyphContext, tctx.cairoFont);
    cairo.cairo_set_font_size(glyphContext, cast() FONT_SIZE);

    cairo.cairo_glyph_extents(glyphContext, cairoGlyph, 1, &cached.extents);

    -- clear the background
    cairo.cairo_set_source_rgb(glyphContext, 0.1739, 0.1867, 0.1433);
    cairo.cairo_rectangle(glyphContext,
        0, 0,
        cast() 40, cast() 40);
    cairo.cairo_fill(glyphContext);

    cairo.cairo_set_source_rgb(glyphContext, 0.965, 0.965, 0.941);
    cairo.cairo_translate(glyphContext, 0, -cached.extents.yBearing);
    cairo.cairo_show_glyphs(glyphContext, cairoGlyph, 1);

    &tctx.glyphCache|append(cached);
    return cached;
}

fn drawText(tctx: *TextContext) {
    -- Reset HarfBuzz buffer
    hb.hb_buffer_reset(tctx.hbBuffer);

    -- Set buffer to LTR direction, common script and default language
    hb.hb_buffer_set_direction(tctx.hbBuffer, hb.HB_DIRECTION_LTR);
    hb.hb_buffer_set_script(tctx.hbBuffer, hb.HB_SCRIPT_COMMON);
    hb.hb_buffer_set_language(tctx.hbBuffer, hb.hb_language_get_default());

    -- Add text and lay it out
    text := se.editor_buffer_get_text_between_points(tctx.eb, 0, 0, 1, 0);

    hb.hb_buffer_add_utf8(tctx.hbBuffer, text.bytes, -1, 0, -1);
    hb.hb_shape(tctx.hbFont, tctx.hbBuffer, nil, 0);

    -- Get buffer data
    glyphCount := hb.hb_buffer_get_length(tctx.hbBuffer);
    glyphInfo := hb.hb_buffer_get_glyph_infos(tctx.hbBuffer, nil);
    glyphPos := hb.hb_buffer_get_glyph_positions(tctx.hbBuffer, nil);

    x: f64 = 0;
    y: f64 = 30;

    for i: iter.until(cast() glyphCount) {
        cairo.cairo_save(tctx.cairoContext);
        cairo.cairo_translate(tctx.cairoContext, x, y + found.extents.yBearing);

        found := findGlyph(tctx, cast() (glyphInfo + i).codepoint);

        cairo.cairo_set_source(tctx.cairoContext, found.pattern);
        cairo.cairo_rectangle(tctx.cairoContext,
            found.extents.xBearing,
            0,
            cast() (found.extents.width + 1),
            cast() (found.extents.height + 1));
        cairo.cairo_fill(tctx.cairoContext);

        cairo.cairo_restore(tctx.cairoContext);

        x += found.extents.xAdvance;
    }
}

fn initSdl(tctx: *TextContext) {
    err := sdl.SDL_Init(sdl.INIT_VIDEO);
    if err != 0 {
        io.println("failed to init SDL");
        panic();
    }

    window := sdl.SDL_CreateWindow("text"|io.cstr,
        sdl.WINDOWPOS_UNDEFINED, sdl.WINDOWPOS_UNDEFINED,
        WIDTH, HEIGHT,
        8196);
    if window == nil {
        io.println("failed to create window");
        panic();
    }

    tctx.sdlWindow = window;
}

fn shutdown(tctx: *TextContext) {
    cairo.cairo_surface_destroy(tctx.cairoSurface);
    cairo.cairo_destroy(tctx.cairoContext);
    cairo.cairo_font_face_destroy(tctx.cairoFont);
    hb.hb_font_destroy(tctx.hbFont);
    sdl.SDL_FreeSurface(tctx.sdlSurface);
    sdl.SDL_Quit();
}

fn demo() {
    tctx: TextContext;

    tctx.eb = se.editor_buffer_create(80);

    initSdl(&tctx);

    loadFonts(&tctx);
    initCairo(&tctx);

    clear(&tctx);
    drawText(&tctx);
    commit(&tctx);

    while !tctx.done {
        event: sdl.KeyboardEvent;

        while sdl.SDL_PollEvent(&event) != 0 {
            if event._type == sdl.QUIT {
                tctx.done = true;
            }
            else if event._type == sdl.KEYDOWN {
                io.println(cast(i32) event.keysym.scancode);

                if event.keysym.scancode == sdl.Key.BACKSPACE {
                    se.editor_buffer_set_cursor_is_selection(tctx.eb, 1);
                    se.editor_buffer_set_cursor_pos_relative(tctx.eb, -1);
                    se.editor_buffer_delete(tctx.eb);
                    se.editor_buffer_set_cursor_is_selection(tctx.eb, 0);
                }
                else if event.keysym.scancode == sdl.Key.SPACE {
                    se.editor_buffer_insert(tctx.eb, " \0".data);
                }
                else if event.keysym.scancode|isalpha {
                    se.editor_buffer_insert(tctx.eb, charsFor(event.keysym.scancode));
                }

                clear(&tctx);
                drawText(&tctx);
                commit(&tctx);
            }
        }
    }

    shutdown(&tctx);
}

fn main() {
    demo();
}
