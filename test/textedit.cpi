#import "sdl";
#import "gui";
#import "buffer": buf;
#import "io";
#import "mem";
#import "se";
#import "cairo";
#import "iter";
#import "harfbuzz": hb;
#import "freetype": ft;
#import "string";

FONT_SIZE : i32 = 20;

TEXT_UPDATE := "text_update";

#context mouse: struct {
    x: i32,
    y: i32
}

type MouseMessageData struct {
    x: f64,
    y: f64
}

type CachedGlyph struct {
    codepoint: i32,
    extents: cairo.GlyphExtents,
    pattern: *cairo.Pattern
}

type CachedLine struct {
    low: f64,
    high: f64,
    glyphs: buf.Buffer!(gui.Rect!(f64))
}

#context tc: struct {
    eb: *se.EditorBuffer,

    font: []i8,

    glyphCache: buf.Buffer!(CachedGlyph),
    lineCache: buf.Buffer!(CachedLine),
}

#context hb: struct {
    font: *hb.Font,
    buffer: *hb.Buffer = nil,
}

fn cacheGlyph(codepoint: i32) {
    cairoGlyph := cairo.cairo_glyph_allocate(1);
    defer { cairo.cairo_glyph_free(cairoGlyph); }

    cairoGlyph.index = cast() codepoint;
    cairoGlyph.x = 0;
    cairoGlyph.y = 0;

    cached: CachedGlyph;
    cached.codepoint = codepoint;

    glyphSurface := cairo.cairo_image_surface_create(
            cairo.FORMAT_RGB24,
            cast() 500,
            cast() 500);
    cached.pattern = cairo.cairo_pattern_create_for_surface(glyphSurface);

    -- Scale cairo to use screen resolution
    xScale: f64;
    yScale: f64;
    cairo.cairo_surface_get_device_scale(context.cairo.surface, &xScale, &yScale);
    cairo.cairo_surface_set_device_scale(glyphSurface, xScale, yScale);

    -- Get Cairo context from Cairo surface
    glyphContext := cairo.cairo_create(glyphSurface);

    cairo.cairo_set_font_face(glyphContext, context.cairo.font);
    cairo.cairo_set_font_size(glyphContext, cast() FONT_SIZE);

    cairo.cairo_glyph_extents(glyphContext, cairoGlyph, 1, &cached.extents);

    -- clear the background
    cairo.cairo_set_source_rgb(glyphContext, 0.1739, 0.1867, 0.1433);
    cairo.cairo_rectangle(glyphContext,
        0, 0,
        cast() 40, cast() 40);
    cairo.cairo_fill(glyphContext);

    cairo.cairo_set_source_rgb(glyphContext, 0.965, 0.965, 0.941);
    cairo.cairo_translate(glyphContext, 0, -cached.extents.yBearing);
    cairo.cairo_show_glyphs(glyphContext, cairoGlyph, 1);

    &context.tc.glyphCache|:append(cached);
    return cached;
}

fn findGlyph(codepoint: i32) CachedGlyph {
    for g: context.tc.glyphCache.buf {
        if g.codepoint == codepoint {
            return g;
        }
    }

    return cacheGlyph(codepoint);
}

fn drawLine(form: gui.Form, formData: *TextEditFormData, line: i64) {
    -- Reset HarfBuzz buffer
    hb.hb_buffer_reset(context.hb.buffer);

    -- Set buffer to LTR direction, common script and default language
    hb.hb_buffer_set_direction(context.hb.buffer, hb.HB_DIRECTION_LTR);
    hb.hb_buffer_set_script(context.hb.buffer, hb.HB_SCRIPT_COMMON);
    hb.hb_buffer_set_language(context.hb.buffer, hb.hb_language_get_default());

    -- Add text and lay it out
    lastChar := se.editor_buffer_get_line_length(context.tc.eb, line);
    text := se.editor_buffer_get_text_between_points(context.tc.eb, line, 0, line, lastChar);

    hb.hb_buffer_add_utf8(context.hb.buffer, text.bytes, -1, 0, -1);
    hb.hb_shape(context.hb.font, context.hb.buffer, nil, 0);

    -- Get buffer data
    glyphCount := hb.hb_buffer_get_length(context.hb.buffer);
    glyphInfo := hb.hb_buffer_get_glyph_infos(context.hb.buffer, nil);
    glyphPos := hb.hb_buffer_get_glyph_positions(context.hb.buffer, nil);

    if glyphCount == 0 { return; }

    -- try to find the cachedLine. If we can't make a new one
    if context.tc.lineCache.buf.count <= line {
        cl: CachedLine = {cast() (context.sdl.windowHeight + 10), 0, buf.make!(gui.Rect!(f64))()};
        &context.tc.lineCache|:set(line, cl);
        context.tc.lineCache.buf.count = line + 1;
    }
    cl := &context.tc.lineCache.buf[line];
    cl.glyphs.buf.count = 0;

    x: f64 = 5;
    y: f64 = cast() (cast() FONT_SIZE * (line + 1));

    for i: iter.until(cast() glyphCount) {
        found := findGlyph(cast() (glyphInfo + i).codepoint);

        cairo.cairo_save(context.cairo.context);
        cairo.cairo_translate(context.cairo.context, form.rect.x + x, form.rect.y + y + found.extents.yBearing);

        cairo.cairo_set_source(context.cairo.context, found.pattern);
        cairo.cairo_rectangle(context.cairo.context,
            found.extents.xBearing,
            0,
            cast() (found.extents.width + 1),
            cast() (found.extents.height + 1));
        cairo.cairo_fill(context.cairo.context);

        if y + found.extents.yBearing < cl.low {
            cl.low = y + found.extents.yBearing;
        }
        if y + found.extents.yBearing + cast() (found.extents.height + 1) > cl.high {
            cl.high = y + found.extents.yBearing + found.extents.height + 1;
        }

        &cl.glyphs|:set(i, {
            x + found.extents.xBearing,
            y + found.extents.yBearing,
            cast() (found.extents.width + 1),
            cast() (found.extents.height + 1)
        });

        cairo.cairo_restore(context.cairo.context);

        x += found.extents.xAdvance;
    }
}

type TextEditFormData struct {
    highlights: buf.Buffer!(gui.Rect!(f64)),
}

fn addTextEdit(rect: gui.Rect!(f64)) {
    fn draw(form: gui.Form, formData: *TextEditFormData, messageData: *none) {
        -- clear
        form|gui.drawRect(form.rect, 0.1739, 0.1867, 0.1433);

        lineCount := se.editor_buffer_get_line_count(context.tc.eb);

        for line: iter.until(lineCount) {
            drawLine(form, formData, line);
        }

        for highlight: formData.highlights.buf {
            form|gui.drawRect(highlight, 0, 1, 0);
        }
    }

    fn mousemove(form: gui.Form, formData: *TextEditFormData, messageData: *MouseMessageData) {
        formData.highlights.buf.count = 0;

        -- translate the mouse coordinates to be relative to our mouse form
        relX := context.mouse.x - cast() form.rect.x;
        relY := context.mouse.y - cast() form.rect.y;

        -- Mouse cursor
        -- cursor: gui.Rect!(f64) = {cast() (context.mouse.x - 10), cast() (context.mouse.y - 10), 20, 20};
        -- &formData.highlights|:append(cursor);

        line := cast(i64) (relY / FONT_SIZE);

        if line >= 0 and line < context.tc.lineCache.buf.count {
            cl := context.tc.lineCache.buf[line];
            for g: cl.glyphs.buf {
                if g|:contains(cast() relX, cast() relY) {
                    -- single character
                    charRect: gui.Rect!(f64) = {form.rect.x + g.x, form.rect.y + g.y, g.width, g.height};
                    &formData.highlights|:append(charRect);

                    gui.setFormNeedsDraw(form);
                }
            }

            -- entire line
            -- lineRect: gui.Rect!(f64) = {form.rect.x, form.rect.y + cl.low - 1, cast() context.sdl.windowWidth, cl.high - cl.low + 2};
            -- &formData.highlights|:append(lineRect);
        }
    }

    formData: TextEditFormData;
    formData.highlights = buf.make!(gui.Rect!(f64))();

    form := gui.makeForm(rect, nil);

    &form.receivers|:append({ gui.DRAW|string.strcpy, draw });
    &form.receivers|:append({ gui.MOUSEMOVE|string.strcpy, mousemove });
    &form.receivers|:append({ TEXT_UPDATE|string.strcpy, gui.setNeedsDraw });

    &context.forms|:append(form);
    &context.mousers|:append(form);
}

-- todo(chad): forms should have an id...
type SliderFormData struct {
    id: i64,

    max: i64,
    current: i64 = 0,

    mouseDown := false,
    grabberRect: gui.Rect!(f64)
}

fn addSlider(rect: gui.Rect!(f64), id: i64, max: i64) {
    fn draw(form: gui.Form, formData: *SliderFormData, messageData: *none) {
        -- magenta background
        form|gui.drawRect(form.rect, 1, 0, 1);

        -- set the max
        formData.max = se.editor_buffer_get_undo_size(context.tc.eb);

        -- cyan slider-grabber
        formData.grabberRect = form.rect;
        formData.grabberRect.x = form.rect.width * cast(f64) formData.current / cast(f64) formData.max;
        formData.grabberRect.width = form.rect.width / cast() formData.max;
        form|gui.drawRect(formData.grabberRect, 0, 1, 1);
    }

    fn mouseDown(form: gui.Form, formData: *SliderFormData, messageData: *MouseMessageData) {
        if formData.grabberRect|gui.contains(messageData.x, messageData.y) {
            formData.mouseDown = true;
        }
    }

    fn mouseMove(form: gui.Form, formData: *SliderFormData, messageData: *MouseMessageData) {
        if formData.mouseDown {
            oldCurrent := formData.current;
            formData.current = cast(i64) (cast(f64) messageData.x * cast(f64) formData.max / form.rect.width);

            if oldCurrent != formData.current {
                se.editor_buffer_undo(context.tc.eb, formData.current);

                gui.setNeedsDraw(form, nil, nil);
                gui.broadcast(TEXT_UPDATE);
            }
        }
    }

    fn mouseUp(form: gui.Form, formData: *SliderFormData, messageData: *MouseMessageData) {
        formData.mouseDown = false;
    }

    sfd: SliderFormData;
    sfd.id = id;
    sfd.max = max;
    form := gui.makeForm(rect, sfd);

    &form.receivers|:append({ gui.DRAW|string.strcpy, draw });
    &form.receivers|:append({ gui.MOUSEDOWN|string.strcpy, mouseDown });
    &form.receivers|:append({ gui.MOUSEMOVE|string.strcpy, mouseMove });
    &form.receivers|:append({ gui.MOUSEUP|string.strcpy, mouseUp });
    &form.receivers|:append({ TEXT_UPDATE|string.strcpy, gui.setNeedsDraw });

    &context.mousers|:append(form);
    &context.forms|:append(form);
}

fn loadFonts() {
    -- context.tc.font = "/System/Library/Fonts/Apple Color Emoji.ttc";
    -- context.tc.font = "/Users/chadrussell/Projects/text/Noto-unhinted/NotoColorEmoji.ttf";
    -- context.tc.font = "/Users/chadrussell/Projects/text/emojione-apple.ttc";
    -- context.tc.font = "/Users/chadrussell/Library/Fonts/Roboto-Light.ttf";
    context.tc.font = "/Library/Fonts/Inconsolata.otf";
    -- context.tc.font = "/Users/chadrussell/Projects/text/JFWilwod.ttf";

    -- context.tc.text = buf.from("Hello");
    -- context.tc.text = buf.from("🙈");

    -- For CAIRO, load using FreeType
    ftLibrary: ft.Library;
    ft.FT_Init_FreeType(&ftLibrary);
    ftFace: ft.Face;
    err := ft.FT_New_Face(ftLibrary, context.tc.font|string.cstr, 0, &ftFace);
    if err != 0 {
        io.println("error creating freetype font face");
        panic();
    }
    context.cairo.font = cairo.cairo_ft_font_face_create_for_ft_face(ftFace, 0);

    -- For Harfbuzz, load using OpenType (HarfBuzz FT does not support bitmap font)
    blob := hb.hb_blob_create_from_file(context.tc.font|string.cstr);
    face := hb.hb_face_create(blob, 0);
    context.hb.font = hb.hb_font_create(face);
    hb.hb_ot_font_set_funcs(context.hb.font);
    hb.hb_font_set_scale(context.hb.font, FONT_SIZE * 64, FONT_SIZE * 64);

    context.hb.buffer = hb.hb_buffer_create();
}

fn mallocWithContext(n: i64) {
    return mem.malloc(n);
}

fn loop() {
    frame := 0;

    gui.drawAllForms();

    event: sdl.Event;
    while true {
        -- reset temporary storage
        basic.resetTmp();

        -- reset messages
        context.drawers.buf.count = 0;
        context.messages.buf.count = 0;

        while sdl.SDL_PollEvent(&event) != 0 {
            if event._type == sdl.QUIT {
                gui.shutdown();
                return;
            }
            else if event._type == sdl.MOUSEMOTION {
                mouseEvent := cast(*sdl.MouseMotionEvent) &event;
                if !(mouseEvent.xrel == 0 and mouseEvent.yrel == 0) {
                    sdl.SDL_GetMouseState(&context.mouse.x, &context.mouse.y);

                    mmd: MouseMessageData = {x: cast() context.mouse.x, y: cast() context.mouse.y};
                    for form: context.mousers.buf {
                        form|gui.sendMessage(cast() {gui.MOUSEMOVE, &mmd});
                    }
                }
            }
            else if event._type == sdl.MOUSEBUTTONDOWN {
                mouseEvent := cast(*sdl.MouseButtonEvent) &event;

                mmd: MouseMessageData = {x: cast() context.mouse.x, y: cast() context.mouse.y};
                for form: context.mousers.buf {
                    if form.rect|gui.contains(mmd.x, mmd.y) {
                        form|gui.sendMessage(cast() {gui.MOUSEDOWN, &mmd});
                    }
                }
            }
            else if event._type == sdl.MOUSEBUTTONUP {
                mouseEvent := cast(*sdl.MouseButtonEvent) &event;

                mmd: MouseMessageData = {x: cast() context.mouse.x, y: cast() context.mouse.y};
                for form: context.mousers.buf {
                    form|gui.sendMessage(cast() {gui.MOUSEUP, &mmd});
                }
            }
            else if event._type == sdl.KEYDOWN {
                keyboardEvent := cast(*sdl.KeyboardEvent) &event;
                -- io.println(cast(i32) keyboardEvent.keysym.scancode);

                gui.broadcast(TEXT_UPDATE);

                if keyboardEvent.keysym.scancode == sdl.Key.BACKSPACE {
                    se.editor_buffer_set_cursor_is_selection(context.tc.eb, 1);
                    se.editor_buffer_set_cursor_pos_relative(context.tc.eb, -1);
                    se.editor_buffer_delete(context.tc.eb);
                    se.editor_buffer_set_cursor_is_selection(context.tc.eb, 0);
                }
                else if keyboardEvent.keysym.scancode == sdl.Key.SPACE {
                    se.editor_buffer_insert(context.tc.eb, " \0".data);
                }
                else if keyboardEvent.keysym.scancode == sdl.Key.ENTER {
                    se.editor_buffer_insert(context.tc.eb, "\n\0".data);
                }
                else if keyboardEvent.keysym.scancode|:isalpha {
                    se.editor_buffer_insert(context.tc.eb, :charsFor(keyboardEvent.keysym.scancode));
                }
            }
        }

        gui.processMessages();
        gui.drawUpdatedForms();

        -- io.println(frame);
        frame += 1;
    }
}

fn init() {
    context.tc.eb = se.editor_buffer_create(80);

    context.tc.glyphCache = buf.make!(CachedGlyph)();
    context.tc.lineCache = buf.make!(CachedLine)();

    loadFonts();
}

fn main() {
    basic.initContext();

    init();
    gui.init();

    #import "random";
    #import "iter";
    random.seed();

    rect : gui.Rect!(f64) = {0, 0, 1, 0.1};
    addSlider(rect, 0, 50);

    formRect: gui.Rect!(f64) = {
        x:      0,
        y:      0.1,
        width:  1.0,
        height: 0.9
    };
    addTextEdit(formRect);

    loop();

    return 0;
}
