#import "sdl";
#import "buffer": buf;
#import "io";
#import "cairo";
#import "harfbuzz": hb;
#import "freetype": ft;
#import "iter";
#import "se";

WIDTH     : i32 = 800;
HEIGHT    : i32 = 350;
FONT_SIZE : i32 = 20;

type CachedGlyph struct {
    codepoint: i32,
    extents: cairo.GlyphExtents,
    pattern: *cairo.Pattern
}

type Rect(T := typeof(x)) struct {
    x: T,
    y: T,
    width: T,
    height: T
}

type CachedLine struct {
    low: f64,
    high: f64,
    glyphs: buf.Buffer!(Rect!(f64))
}

type TextContext struct {
    hbFont: *hb.Font,
    hbBuffer: *hb.Buffer = nil,

    cairoFont: *cairo.FontFace,

    cairoSurface: *cairo.Surface,
    cairoContext: *cairo.Context,

    cairoTextSurface: *cairo.Surface,
    cairoTextContext: *cairo.Context,
    cairoTextPattern: *cairo.Pattern,

    font: []i8,
    eb: *se.EditorBuffer,

    glyphCache: buf.Buffer!(CachedGlyph),
    lineCache: buf.Buffer!(CachedLine),

    done := false,

    sdlWindow: *sdl.Window,
    sdlSurface: *sdl.Surface,
    sdlRenderer: *sdl.Renderer,

    windowWidth: i32,
    windowHeight: i32,

    rendererWidth: i32,
    rendererHeight: i32,

    xScale: f64,
    yScale: f64,

    cairoMouseSurface: *cairo.Surface,
    cairoMouseContext: *cairo.Context,
    cairoMousePattern: *cairo.Pattern
}

fn loadFonts(tctx: *TextContext) {
    -- tctx.font = "/System/Library/Fonts/Apple Color Emoji.ttc";
    -- tctx.font = "/Users/chadrussell/Projects/text/Noto-unhinted/NotoColorEmoji.ttf";
    -- tctx.font = "/Users/chadrussell/Projects/text/emojione-apple.ttc";
    -- tctx.font = "/Users/chadrussell/Library/Fonts/Roboto-Light.ttf";
    tctx.font = "/Library/Fonts/Inconsolata.otf";
    -- tctx.font = "/Users/chadrussell/Projects/text/JFWilwod.ttf";

    -- tctx.text = buf.from("Hello");
    -- tctx.text = buf.from("ðŸ™ˆ");

    -- For CAIRO, load using FreeType
    ftLibrary: ft.Library;
    ft.FT_Init_FreeType(&ftLibrary);
    ftFace: ft.Face;
    err := ft.FT_New_Face(ftLibrary, tctx.font|io.cstr, 0, &ftFace);
    if err != 0 {
        io.println("error creating freetype font face");
        panic();
    }
    tctx.cairoFont = cairo.cairo_ft_font_face_create_for_ft_face(ftFace, 0);

    -- For Harfbuzz, load using OpenType (HarfBuzz FT does not support bitmap font)
    blob := hb.hb_blob_create_from_file(tctx.font|io.cstr);
    face := hb.hb_face_create(blob, 0);
    tctx.hbFont = hb.hb_font_create(face);
    hb.hb_ot_font_set_funcs(tctx.hbFont);
    hb.hb_font_set_scale(tctx.hbFont, FONT_SIZE * 64, FONT_SIZE * 64);

    tctx.hbBuffer = hb.hb_buffer_create();
}

fn initCairo(tctx: *TextContext) {
    sdlRenderFlags: i32 = 6;
    tctx.sdlRenderer = sdl.SDL_CreateRenderer(tctx.sdlWindow, -1, sdlRenderFlags);

    -- Compute screen resolution
    -- For instance, on a retina screen, renderer size is twice as window size
    sdl.SDL_GetWindowSize(tctx.sdlWindow, &tctx.windowWidth, &tctx.windowHeight);

    sdl.SDL_GetRendererOutputSize(tctx.sdlRenderer, &tctx.rendererWidth, &tctx.rendererHeight);

    -- Create a SDL surface for Cairo to render onto
    tctx.sdlSurface = sdl.SDL_CreateRGBSurface(
            0,
            tctx.rendererWidth,
            tctx.rendererHeight,
            32,
            0x00ff0000,
            0x0000ff00,
            0x000000ff,
            0
    );

    -- Get Cairo surface form SDL2 surface
    tctx.cairoSurface = cairo.cairo_image_surface_create_for_data(
            cast() tctx.sdlSurface.pixels,
            cairo.FORMAT_RGB24,
            tctx.sdlSurface.w,
            tctx.sdlSurface.h,
            tctx.sdlSurface.pitch);
    tctx.cairoContext = cairo.cairo_create(tctx.cairoSurface);

    tctx.cairoTextSurface = cairo.cairo_image_surface_create(cairo.FORMAT_ARGB32, cast() tctx.sdlSurface.w, cast() tctx.sdlSurface.h);
    tctx.cairoTextPattern = cairo.cairo_pattern_create_for_surface(tctx.cairoTextSurface);

    tctx.xScale = cast(f64) tctx.rendererWidth / cast(f64) tctx.windowWidth;
    tctx.yScale = cast(f64) tctx.rendererHeight / cast(f64) tctx.windowHeight;

    -- Get Cairo context from Cairo surface
    tctx.cairoTextContext = cairo.cairo_create(tctx.cairoTextSurface);
    cairo.cairo_set_antialias(tctx.cairoTextContext, cairo.Antialias.SUBPIXEL);
    cairo.cairo_set_source_rgba(tctx.cairoTextContext, 0.0, 0.0, 0.0, 1.0);
    cairo.cairo_set_font_face(tctx.cairoTextContext, tctx.cairoFont);
    cairo.cairo_set_font_size(tctx.cairoTextContext, cast() FONT_SIZE);

    tctx.glyphCache = buf.make!(CachedGlyph)();
    tctx.lineCache = buf.make!(CachedLine)();

    tctx.cairoMouseSurface = cairo.cairo_image_surface_create(cairo.FORMAT_ARGB32, cast() tctx.sdlSurface.w, cast() tctx.sdlSurface.h);
    tctx.cairoMousePattern = cairo.cairo_pattern_create_for_surface(tctx.cairoMouseSurface);

    tctx.cairoMouseContext = cairo.cairo_create(tctx.cairoMouseSurface);

    -- Scale cairo to use screen resolution
    cairo.cairo_surface_set_device_scale(tctx.cairoTextSurface, tctx.xScale, tctx.yScale);
    cairo.cairo_surface_set_device_scale(tctx.cairoMouseSurface, tctx.xScale, tctx.yScale);
    cairo.cairo_surface_set_device_scale(tctx.cairoSurface, tctx.xScale, tctx.yScale);
}

fn drawMouse(tctx: *TextContext, x: i32, y: i32) {
    -- Clear
    cairo.cairo_save(tctx.cairoMouseContext);
    cairo.cairo_set_operator(tctx.cairoMouseContext, cairo.Operator.CAIRO_OPERATOR_CLEAR);
    cairo.cairo_paint(tctx.cairoMouseContext);
    cairo.cairo_restore(tctx.cairoMouseContext);

    -- Mouse cursor
    -- cairo.cairo_save(tctx.cairoMouseContext);
    -- cairo.cairo_set_source_rgba(tctx.cairoMouseContext, 0.9, 0.9, 1, 1);
    -- cairo.cairo_rectangle(tctx.cairoMouseContext, cast() (x - 10), cast() (y - 10), 20, 20);
    -- cairo.cairo_fill(tctx.cairoMouseContext);
    -- cairo.cairo_restore(tctx.cairoMouseContext);

    -- Highlight line
    cairo.cairo_save(tctx.cairoMouseContext);
    cairo.cairo_set_source_rgba(tctx.cairoMouseContext, 0.2, 0.2, 0.4, 0.9);

    line := cast(i64) (y / FONT_SIZE);

    -- single character
    if line >= 0 and line <= tctx.lineCache.buf.count {
        cl := tctx.lineCache.buf[line];
        for g: cl.glyphs.buf {
            -- todo(chad): write 'rect contains point' fn
            if g.x <= cast() x and g.y <= cast() y and g.x + g.width >= cast() x and g.y + g.height >= cast() y {
                cairo.cairo_rectangle(tctx.cairoMouseContext, g.x, g.y, g.width, g.height);
                cairo.cairo_fill(tctx.cairoMouseContext);
            }
        }
    }

    -- entire line
    -- cairo.cairo_rectangle(tctx.cairoMouseContext, 0, cl.low - 1, cast() tctx.windowWidth, cl.high - cl.low + 2);
    -- cairo.cairo_fill(tctx.cairoMouseContext);

    cairo.cairo_restore(tctx.cairoMouseContext);
}

fn clear(tctx: *TextContext) {
    -- Fill background
    cairo.cairo_save(tctx.cairoTextContext);
    cairo.cairo_set_source_rgb(tctx.cairoTextContext, 0.1739, 0.1867, 0.1433);
    cairo.cairo_rectangle(tctx.cairoTextContext,
        0, 0,
        cast() cairo.cairo_image_surface_get_width(tctx.cairoTextSurface), cast() cairo.cairo_image_surface_get_height(tctx.cairoTextSurface));
    cairo.cairo_fill(tctx.cairoTextContext);
    cairo.cairo_restore(tctx.cairoTextContext);
}

fn commit(tctx: *TextContext) {
    -- Copy the text pattern
    cairo.cairo_set_source(tctx.cairoContext, tctx.cairoTextPattern);
    cairo.cairo_paint(tctx.cairoContext);

    -- Copy the mouse pattern
    cairo.cairo_set_source(tctx.cairoContext, tctx.cairoMousePattern);
    cairo.cairo_set_operator(tctx.cairoContext, cairo.Operator.CAIRO_OPERATOR_OVER);
    cairo.cairo_paint(tctx.cairoContext);

    -- Render SDL2 surface onto SDL2 renderer
    texture := sdl.SDL_CreateTextureFromSurface(tctx.sdlRenderer, tctx.sdlSurface);
    sdl.SDL_RenderCopy(tctx.sdlRenderer, texture, nil, nil);
    sdl.SDL_RenderPresent(tctx.sdlRenderer);
}

fn findGlyph(tctx: *TextContext, codepoint: i32) CachedGlyph {
    for g: tctx.glyphCache.buf {
        if g.codepoint == codepoint {
            return g;
        }
    }

    return cacheGlyph(tctx, codepoint);
}

fn cacheGlyph(tctx: *TextContext, codepoint: i32) {
    cairoGlyph := cairo.cairo_glyph_allocate(1);
    defer { cairo.cairo_glyph_free(cairoGlyph); }

    cairoGlyph.index = cast() codepoint;
    cairoGlyph.x = 0;
    cairoGlyph.y = 0;

    cached: CachedGlyph;
    cached.codepoint = codepoint;

    glyphSurface := cairo.cairo_image_surface_create(
            cairo.FORMAT_RGB24,
            cast() 500,
            cast() 500);
    cached.pattern = cairo.cairo_pattern_create_for_surface(glyphSurface);

    -- Scale cairo to use screen resolution
    xScale: f64;
    yScale: f64;
    cairo.cairo_surface_get_device_scale(tctx.cairoTextSurface, &xScale, &yScale);
    cairo.cairo_surface_set_device_scale(glyphSurface, xScale, yScale);

    -- Get Cairo context from Cairo surface
    glyphContext := cairo.cairo_create(glyphSurface);

    cairo.cairo_set_font_face(glyphContext, tctx.cairoFont);
    cairo.cairo_set_font_size(glyphContext, cast() FONT_SIZE);

    cairo.cairo_glyph_extents(glyphContext, cairoGlyph, 1, &cached.extents);

    -- clear the background
    cairo.cairo_set_source_rgb(glyphContext, 0.1739, 0.1867, 0.1433);
    cairo.cairo_rectangle(glyphContext,
        0, 0,
        cast() 40, cast() 40);
    cairo.cairo_fill(glyphContext);

    cairo.cairo_set_source_rgb(glyphContext, 0.965, 0.965, 0.941);
    cairo.cairo_translate(glyphContext, 0, -cached.extents.yBearing);
    cairo.cairo_show_glyphs(glyphContext, cairoGlyph, 1);

    &tctx.glyphCache|append(cached);
    return cached;
}

fn drawLine(tctx: *TextContext, line: i64) {
    -- Reset HarfBuzz buffer
    hb.hb_buffer_reset(tctx.hbBuffer);

    -- Set buffer to LTR direction, common script and default language
    hb.hb_buffer_set_direction(tctx.hbBuffer, hb.HB_DIRECTION_LTR);
    hb.hb_buffer_set_script(tctx.hbBuffer, hb.HB_SCRIPT_COMMON);
    hb.hb_buffer_set_language(tctx.hbBuffer, hb.hb_language_get_default());

    -- Add text and lay it out
    lastChar := se.editor_buffer_get_line_length(tctx.eb, line);
    text := se.editor_buffer_get_text_between_points(tctx.eb, line, 0, line, lastChar);

    hb.hb_buffer_add_utf8(tctx.hbBuffer, text.bytes, -1, 0, -1);
    hb.hb_shape(tctx.hbFont, tctx.hbBuffer, nil, 0);

    -- Get buffer data
    glyphCount := hb.hb_buffer_get_length(tctx.hbBuffer);
    glyphInfo := hb.hb_buffer_get_glyph_infos(tctx.hbBuffer, nil);
    glyphPos := hb.hb_buffer_get_glyph_positions(tctx.hbBuffer, nil);

    cl: CachedLine = {cast() (tctx.windowHeight + 10), 0, buf.make!(Rect!(f64))()};

    x: f64 = 0;
    y: f64 = cast() (cast() FONT_SIZE * (line + 1));

    for i: iter.until(cast() glyphCount) {
        found := findGlyph(tctx, cast() (glyphInfo + i).codepoint);

        cairo.cairo_save(tctx.cairoTextContext);
        cairo.cairo_translate(tctx.cairoTextContext, x + found.extents.xBearing, y + found.extents.yBearing);

        cairo.cairo_set_source(tctx.cairoTextContext, found.pattern);
        cairo.cairo_rectangle(tctx.cairoTextContext,
            0,
            0,
            cast() (found.extents.width + 1),
            cast() (found.extents.height + 1));
        cairo.cairo_fill(tctx.cairoTextContext);

        if y + found.extents.yBearing < cl.low {
            cl.low = y + found.extents.yBearing;
        }
        if y + found.extents.yBearing + cast() (found.extents.height + 1) > cl.high {
            cl.high = y + found.extents.yBearing + found.extents.height + 1;
        }

        &cl.glyphs|append({
            x + found.extents.xBearing,
            y + found.extents.yBearing,
            cast() (found.extents.width + 1),
            cast() (found.extents.height + 1)
        });

        cairo.cairo_restore(tctx.cairoTextContext);

        x += found.extents.xAdvance;
    }

    ensureCapacity(&tctx.lineCache, line + 1);
    tctx.lineCache.buf[line] = cl;

    if tctx.lineCache.buf.count < line {
        tctx.lineCache.buf.count = line + 1;
    }
}

fn drawText(tctx: *TextContext) {
    lineCount := se.editor_buffer_get_line_count(tctx.eb);

    for line: iter.until(lineCount) {
        drawLine(tctx, line);
    }
}

fn initSdl(tctx: *TextContext) {
    err := sdl.SDL_Init(sdl.INIT_VIDEO);
    if err != 0 {
        io.println("failed to init SDL");
        panic();
    }

    window := sdl.SDL_CreateWindow("text"|io.cstr,
        sdl.WINDOWPOS_UNDEFINED, sdl.WINDOWPOS_UNDEFINED,
        WIDTH, HEIGHT,
        8196);
    if window == nil {
        io.println("failed to create window");
        panic();
    }

    tctx.sdlWindow = window;
}

fn shutdown(tctx: *TextContext) {
    cairo.cairo_surface_destroy(tctx.cairoTextSurface);
    cairo.cairo_destroy(tctx.cairoTextContext);

    cairo.cairo_surface_destroy(tctx.cairoMouseSurface);
    cairo.cairo_destroy(tctx.cairoMouseContext);

    cairo.cairo_surface_destroy(tctx.cairoSurface);
    cairo.cairo_destroy(tctx.cairoContext);

    cairo.cairo_font_face_destroy(tctx.cairoFont);

    hb.hb_font_destroy(tctx.hbFont);

    sdl.SDL_FreeSurface(tctx.sdlSurface);
    sdl.SDL_Quit();
}

fn demo() {
    tctx: TextContext;
    tctx.eb = se.editor_buffer_create(80);

    initSdl(&tctx);

    loadFonts(&tctx);
    initCairo(&tctx);

    clear(&tctx);
    drawText(&tctx);
    commit(&tctx);

    while !tctx.done {
        event: sdl.Event;

        while sdl.SDL_PollEvent(&event) != 0 {
            if event._type == sdl.QUIT {
                tctx.done = true;
            }
            else if event._type == sdl.KEYDOWN {
                keyboardEvent := cast(sdl.KeyboardEvent) event;
                -- io.println(cast(i32) keyboardEvent.keysym.scancode);

                if keyboardEvent.keysym.scancode == sdl.Key.BACKSPACE {
                    se.editor_buffer_set_cursor_is_selection(tctx.eb, 1);
                    se.editor_buffer_set_cursor_pos_relative(tctx.eb, -1);
                    se.editor_buffer_delete(tctx.eb);
                    se.editor_buffer_set_cursor_is_selection(tctx.eb, 0);
                }
                else if keyboardEvent.keysym.scancode == sdl.Key.SPACE {
                    se.editor_buffer_insert(tctx.eb, " \0".data);
                }
                else if keyboardEvent.keysym.scancode == sdl.Key.ENTER {
                    se.editor_buffer_insert(tctx.eb, "\n\0".data);
                }
                else if keyboardEvent.keysym.scancode|isalpha {
                    se.editor_buffer_insert(tctx.eb, charsFor(keyboardEvent.keysym.scancode));
                }

                clear(&tctx);
                drawText(&tctx);
                commit(&tctx);
            }
            else if event._type == sdl.MOUSEMOTION {
                mouseEvent := cast(sdl.MouseMotionEvent) event;

                xMouse: i32;
                yMouse: i32;
                sdl.SDL_GetMouseState(&xMouse, &yMouse);

                drawMouse(&tctx, xMouse, yMouse);
                commit(&tctx);
            }
        }
    }

    shutdown(&tctx);
}

fn main() {
    demo();
}
