#import "sdl";
#import "buffer": buf;
#import "io";
#import "cairo";
#import "harfbuzz": hb;
#import "freetype": ft;
#import "iter";
#import "se";
#import "mem";

WIDTH     : i32 = 800;
HEIGHT    : i32 = 350;
FONT_SIZE : i32 = 20;

#contextinit fn() { io.println("textedit init-ing context"); }

type CachedGlyph struct {
    codepoint: i32,
    extents: cairo.GlyphExtents,
    pattern: *cairo.Pattern
}

type Rect(T := typeof(x)) struct {
    x: T,
    y: T,
    width: T,
    height: T
}

type CachedLine struct {
    low: f64,
    high: f64,
    glyphs: buf.Buffer!(Rect!(f64))
}

#context cairo: struct {
    font: *cairo.FontFace,

    surface: *cairo.Surface,
    context: *cairo.Context,

    textSurface: *cairo.Surface,
    textContext: *cairo.Context,
    textPattern: *cairo.Pattern,

    mouseSurface: *cairo.Surface,
    mouseContext: *cairo.Context,
    mousePattern: *cairo.Pattern,
}

#context sdl: struct {
    window: *sdl.Window,
    surface: *sdl.Surface,
    renderer: *sdl.Renderer,

    windowWidth: i32,
    windowHeight: i32,

    rendererWidth: i32,
    rendererHeight: i32,

    xScale: f64,
    yScale: f64,
}

#context hb: struct {
    font: *hb.Font,
    buffer: *hb.Buffer = nil,
}

#context tc: struct {
    eb: *se.EditorBuffer,

    font: []i8,

    glyphCache: buf.Buffer!(CachedGlyph),
    lineCache: buf.Buffer!(CachedLine),
}

fn loadFonts() {
    -- context.tc.font = "/System/Library/Fonts/Apple Color Emoji.ttc";
    -- context.tc.font = "/Users/chadrussell/Projects/text/Noto-unhinted/NotoColorEmoji.ttf";
    -- context.tc.font = "/Users/chadrussell/Projects/text/emojione-apple.ttc";
    -- context.tc.font = "/Users/chadrussell/Library/Fonts/Roboto-Light.ttf";
    context.tc.font = "/Library/Fonts/Inconsolata.otf";
    -- context.tc.font = "/Users/chadrussell/Projects/text/JFWilwod.ttf";

    -- context.tc.text = buf.from("Hello");
    -- context.tc.text = buf.from("ðŸ™ˆ");

    -- For CAIRO, load using FreeType
    ftLibrary: ft.Library;
    ft.FT_Init_FreeType(&ftLibrary);
    ftFace: ft.Face;
    err := ft.FT_New_Face(ftLibrary, context.tc.font|io.cstr, 0, &ftFace);
    if err != 0 {
        io.println("error creating freetype font face");
        panic();
    }
    context.cairo.font = cairo.cairo_ft_font_face_create_for_ft_face(ftFace, 0);

    -- For Harfbuzz, load using OpenType (HarfBuzz FT does not support bitmap font)
    blob := hb.hb_blob_create_from_file(context.tc.font|io.cstr);
    face := hb.hb_face_create(blob, 0);
    context.hb.font = hb.hb_font_create(face);
    hb.hb_ot_font_set_funcs(context.hb.font);
    hb.hb_font_set_scale(context.hb.font, FONT_SIZE * 64, FONT_SIZE * 64);

    context.hb.buffer = hb.hb_buffer_create();
}

fn initCairo() {
    sdlRenderFlags: i32 = 6;
    context.sdl.renderer = sdl.SDL_CreateRenderer(context.sdl.window, -1, sdlRenderFlags);

    -- Compute screen resolution
    -- For instance, on a retina screen, renderer size is twice as window size
    sdl.SDL_GetWindowSize(context.sdl.window, &context.sdl.windowWidth, &context.sdl.windowHeight);

    sdl.SDL_GetRendererOutputSize(context.sdl.renderer, &context.sdl.rendererWidth, &context.sdl.rendererHeight);

    -- Create a SDL surface for Cairo to render onto
    context.sdl.surface = sdl.SDL_CreateRGBSurface(
            0,
            context.sdl.rendererWidth,
            context.sdl.rendererHeight,
            32,
            0x00ff0000,
            0x0000ff00,
            0x000000ff,
            0
    );

    -- Get Cairo surface form SDL2 surface
    context.cairo.surface = cairo.cairo_image_surface_create_for_data(
            cast() context.sdl.surface.pixels,
            cairo.FORMAT_RGB24,
            context.sdl.surface.w,
            context.sdl.surface.h,
            context.sdl.surface.pitch);
    context.cairo.context = cairo.cairo_create(context.cairo.surface);

    context.cairo.textSurface = cairo.cairo_image_surface_create(cairo.FORMAT_ARGB32, cast() context.sdl.surface.w, cast() context.sdl.surface.h);
    context.cairo.textPattern = cairo.cairo_pattern_create_for_surface(context.cairo.textSurface);

    context.sdl.xScale = cast(f64) context.sdl.rendererWidth / cast(f64) context.sdl.windowWidth;
    context.sdl.yScale = cast(f64) context.sdl.rendererHeight / cast(f64) context.sdl.windowHeight;

    -- Get Cairo context from Cairo surface
    context.cairo.textContext = cairo.cairo_create(context.cairo.textSurface);
    cairo.cairo_set_antialias(context.cairo.textContext, cairo.Antialias.SUBPIXEL);
    cairo.cairo_set_source_rgba(context.cairo.textContext, 0.0, 0.0, 0.0, 1.0);
    cairo.cairo_set_font_face(context.cairo.textContext, context.cairo.font);
    cairo.cairo_set_font_size(context.cairo.textContext, cast() FONT_SIZE);

    context.tc.glyphCache = buf.make!(CachedGlyph)();
    context.tc.lineCache = buf.make!(CachedLine)();

    context.cairo.mouseSurface = cairo.cairo_image_surface_create(cairo.FORMAT_ARGB32, cast() context.sdl.surface.w, cast() context.sdl.surface.h);
    context.cairo.mousePattern = cairo.cairo_pattern_create_for_surface(context.cairo.mouseSurface);

    context.cairo.mouseContext = cairo.cairo_create(context.cairo.mouseSurface);

    -- Scale cairo to use screen resolution
    cairo.cairo_surface_set_device_scale(context.cairo.textSurface, context.sdl.xScale, context.sdl.yScale);
    cairo.cairo_surface_set_device_scale(context.cairo.mouseSurface, context.sdl.xScale, context.sdl.yScale);
    cairo.cairo_surface_set_device_scale(context.cairo.surface, context.sdl.xScale, context.sdl.yScale);
}

fn drawMouse(x: i32, y: i32) {
    -- Clear
    cairo.cairo_save(context.cairo.mouseContext);
    cairo.cairo_set_operator(context.cairo.mouseContext, cairo.Operator.CAIRO_OPERATOR_CLEAR);
    cairo.cairo_paint(context.cairo.mouseContext);
    cairo.cairo_restore(context.cairo.mouseContext);

    -- Mouse cursor
    -- cairo.cairo_save(context.cairo.MouseContext);
    -- cairo.cairo_set_source_rgba(context.cairo.MouseContext, 0.9, 0.9, 1, 1);
    -- cairo.cairo_rectangle(context.cairo.MouseContext, cast() (x - 10), cast() (y - 10), 20, 20);
    -- cairo.cairo_fill(context.cairo.MouseContext);
    -- cairo.cairo_restore(context.cairo.MouseContext);

    -- Highlight line
    cairo.cairo_save(context.cairo.mouseContext);
    cairo.cairo_set_source_rgba(context.cairo.mouseContext, 0.0, 0.9, 0.0, 0.9);

    line := cast(i64) (y / FONT_SIZE);

    -- single character
    if line >= 0 and line < context.tc.lineCache.buf.count {
        cl := context.tc.lineCache.buf[line];
        for g: cl.glyphs.buf {
            -- todo(chad): write 'rect contains point' fn
            if g.x <= cast() x and g.y <= cast() y and g.x + g.width >= cast() x and g.y + g.height >= cast() y {
                cairo.cairo_rectangle(context.cairo.mouseContext, g.x, g.y, g.width, g.height);
                cairo.cairo_fill(context.cairo.mouseContext);
            }
        }
    }

    -- entire line
    -- cairo.cairo_rectangle(context.cairo.mouseContext, 0, cl.low - 1, cast() context.tc.windowWidth, cl.high - cl.low + 2);
    -- cairo.cairo_fill(context.cairo.mouseContext);

    cairo.cairo_restore(context.cairo.mouseContext);
}

fn clear() {
    -- Fill background
    cairo.cairo_save(context.cairo.textContext);
    cairo.cairo_set_source_rgb(context.cairo.textContext, 0.1739, 0.1867, 0.1433);
    cairo.cairo_rectangle(context.cairo.textContext,
        0, 0,
        cast() cairo.cairo_image_surface_get_width(context.cairo.textSurface), cast() cairo.cairo_image_surface_get_height(context.cairo.textSurface));
    cairo.cairo_fill(context.cairo.textContext);
    cairo.cairo_restore(context.cairo.textContext);
}

fn commit() {
    -- Copy the text pattern
    cairo.cairo_set_source(context.cairo.context, context.cairo.textPattern);
    cairo.cairo_paint(context.cairo.context);

    -- Copy the mouse pattern
    cairo.cairo_set_source(context.cairo.context, context.cairo.mousePattern);
    cairo.cairo_set_operator(context.cairo.context, cairo.Operator.CAIRO_OPERATOR_OVER);
    cairo.cairo_paint(context.cairo.context);

    -- Render SDL2 surface onto SDL2 renderer
    texture := sdl.SDL_CreateTextureFromSurface(context.sdl.renderer, context.sdl.surface);
    sdl.SDL_RenderCopy(context.sdl.renderer, texture, nil, nil);
    sdl.SDL_RenderPresent(context.sdl.renderer);
}

fn findGlyph(codepoint: i32) CachedGlyph {
    for g: context.tc.glyphCache.buf {
        if g.codepoint == codepoint {
            return g;
        }
    }

    return cacheGlyph(codepoint);
}

fn cacheGlyph(codepoint: i32) {
    cairoGlyph := cairo.cairo_glyph_allocate(1);
    defer { cairo.cairo_glyph_free(cairoGlyph); }

    cairoGlyph.index = cast() codepoint;
    cairoGlyph.x = 0;
    cairoGlyph.y = 0;

    cached: CachedGlyph;
    cached.codepoint = codepoint;

    glyphSurface := cairo.cairo_image_surface_create(
            cairo.FORMAT_RGB24,
            cast() 500,
            cast() 500);
    cached.pattern = cairo.cairo_pattern_create_for_surface(glyphSurface);

    -- Scale cairo to use screen resolution
    xScale: f64;
    yScale: f64;
    cairo.cairo_surface_get_device_scale(context.cairo.textSurface, &xScale, &yScale);
    cairo.cairo_surface_set_device_scale(glyphSurface, xScale, yScale);

    -- Get Cairo context from Cairo surface
    glyphContext := cairo.cairo_create(glyphSurface);

    cairo.cairo_set_font_face(glyphContext, context.cairo.font);
    cairo.cairo_set_font_size(glyphContext, cast() FONT_SIZE);

    cairo.cairo_glyph_extents(glyphContext, cairoGlyph, 1, &cached.extents);

    -- clear the background
    cairo.cairo_set_source_rgb(glyphContext, 0.1739, 0.1867, 0.1433);
    cairo.cairo_rectangle(glyphContext,
        0, 0,
        cast() 40, cast() 40);
    cairo.cairo_fill(glyphContext);

    cairo.cairo_set_source_rgb(glyphContext, 0.965, 0.965, 0.941);
    cairo.cairo_translate(glyphContext, 0, -cached.extents.yBearing);
    cairo.cairo_show_glyphs(glyphContext, cairoGlyph, 1);

    &context.tc.glyphCache|:append(cached);
    return cached;
}

fn drawLine(line: i64) {
    -- Reset HarfBuzz buffer
    hb.hb_buffer_reset(context.hb.buffer);

    -- Set buffer to LTR direction, common script and default language
    hb.hb_buffer_set_direction(context.hb.buffer, hb.HB_DIRECTION_LTR);
    hb.hb_buffer_set_script(context.hb.buffer, hb.HB_SCRIPT_COMMON);
    hb.hb_buffer_set_language(context.hb.buffer, hb.hb_language_get_default());

    -- Add text and lay it out
    lastChar := se.editor_buffer_get_line_length(context.tc.eb, line);
    text := se.editor_buffer_get_text_between_points(context.tc.eb, line, 0, line, lastChar);

    hb.hb_buffer_add_utf8(context.hb.buffer, text.bytes, -1, 0, -1);
    hb.hb_shape(context.hb.font, context.hb.buffer, nil, 0);

    -- Get buffer data
    glyphCount := hb.hb_buffer_get_length(context.hb.buffer);
    glyphInfo := hb.hb_buffer_get_glyph_infos(context.hb.buffer, nil);
    glyphPos := hb.hb_buffer_get_glyph_positions(context.hb.buffer, nil);

    clGlyphs := buf.make!(Rect!(f64))();
    cl: CachedLine = {cast() (context.sdl.windowHeight + 10), 0, clGlyphs};

    x: f64 = 5;
    y: f64 = cast() (cast() FONT_SIZE * (line + 1));

    for i: iter.until(cast() glyphCount) {
        found := findGlyph(cast() (glyphInfo + i).codepoint);

        cairo.cairo_save(context.cairo.textContext);
        cairo.cairo_translate(context.cairo.textContext, x, y + found.extents.yBearing);

        cairo.cairo_set_source(context.cairo.textContext, found.pattern);
        cairo.cairo_rectangle(context.cairo.textContext,
            found.extents.xBearing,
            0,
            cast() (found.extents.width + 1),
            cast() (found.extents.height + 1));
        cairo.cairo_fill(context.cairo.textContext);

        if y + found.extents.yBearing < cl.low {
            cl.low = y + found.extents.yBearing;
        }
        if y + found.extents.yBearing + cast() (found.extents.height + 1) > cl.high {
            cl.high = y + found.extents.yBearing + found.extents.height + 1;
        }

        &cl.glyphs|:append({
            x + found.extents.xBearing,
            y + found.extents.yBearing,
            cast() (found.extents.width + 1),
            cast() (found.extents.height + 1)
        });

        cairo.cairo_restore(context.cairo.textContext);

        x += found.extents.xAdvance;
    }

    :ensureCapacity(&context.tc.lineCache, line + 1);
    context.tc.lineCache.buf[line] = cl;

    if context.tc.lineCache.buf.count < line + 1 {
        context.tc.lineCache.buf.count = line + 1;
    }
}

fn drawText() {
    basic.resetTmp();
    context.tc.lineCache = buf.make!(CachedLine)();

    clear();

    lineCount := se.editor_buffer_get_line_count(context.tc.eb);

    for line: iter.until(lineCount) {
        drawLine(line);
    }
}

fn initSdl() {
    err := sdl.SDL_Init(sdl.INIT_VIDEO);
    if err != 0 {
        io.println("failed to init SDL");
        panic();
    }

    window := sdl.SDL_CreateWindow("text"|io.cstr,
        sdl.WINDOWPOS_UNDEFINED, sdl.WINDOWPOS_UNDEFINED,
        WIDTH, HEIGHT,
        8196);
    if window == nil {
        io.println("failed to create window");
        panic();
    }

    context.sdl.window = window;
}

fn shutdown() {
    cairo.cairo_surface_destroy(context.cairo.textSurface);
    cairo.cairo_destroy(context.cairo.textContext);

    cairo.cairo_surface_destroy(context.cairo.mouseSurface);
    cairo.cairo_destroy(context.cairo.mouseContext);

    cairo.cairo_surface_destroy(context.cairo.surface);
    cairo.cairo_destroy(context.cairo.context);

    cairo.cairo_font_face_destroy(context.cairo.font);

    hb.hb_font_destroy(context.hb.font);

    sdl.SDL_FreeSurface(context.sdl.surface);
    sdl.SDL_Quit();
}

fn demo() {
    context.tc.eb = se.editor_buffer_create(80);

    initSdl();

    loadFonts();
    initCairo();

    drawText();
    commit();

    event: sdl.Event;
    while sdl.SDL_WaitEvent(&event) != 0 {
        if event._type == sdl.QUIT {
            shutdown();
            return;
        }
        else if event._type == sdl.KEYDOWN {
            keyboardEvent := cast(*sdl.KeyboardEvent) &event;
            -- io.println(cast(i32) keyboardEvent.keysym.scancode);

            if keyboardEvent.keysym.scancode == sdl.Key.BACKSPACE {
                se.editor_buffer_set_cursor_is_selection(context.tc.eb, 1);
                se.editor_buffer_set_cursor_pos_relative(context.tc.eb, -1);
                se.editor_buffer_delete(context.tc.eb);
                se.editor_buffer_set_cursor_is_selection(context.tc.eb, 0);
            }
            else if keyboardEvent.keysym.scancode == sdl.Key.SPACE {
                se.editor_buffer_insert(context.tc.eb, " \0".data);
            }
            else if keyboardEvent.keysym.scancode == sdl.Key.ENTER {
                se.editor_buffer_insert(context.tc.eb, "\n\0".data);
            }
            else if keyboardEvent.keysym.scancode|:isalpha {
                se.editor_buffer_insert(context.tc.eb, :charsFor(keyboardEvent.keysym.scancode));
            }

            drawText();
            commit();
        }
        else if event._type == sdl.MOUSEMOTION {
            mouseEvent := cast(*sdl.MouseMotionEvent) &event;

            xMouse: i32;
            yMouse: i32;
            sdl.SDL_GetMouseState(&xMouse, &yMouse);

            drawMouse(xMouse, yMouse);
            commit();
        }
    }
}

fn main() {
    demo();
}
