#import "sdl";
#import "buffer": buf;
#import "io";
#import "cairo";
#import "mem";

WIDTH   : i32 = 800;
HEIGHT  : i32 = 350;

DRAW     : []i8 = "draw";
MOUSEDOWN: []i8 = "mousedown";
MOUSEMOVE: []i8 = "mousemove";
MOUSEUP  : []i8 = "mouseup";

type Rect(T := typeof(x)) struct {
    x: T,
    y: T,
    width: T,
    height: T
}

type Point(T := typeof(x)) struct {
    x: T,
    y: T,
}

#attr(Rect)
fn contains(T := typeof(r.x))(r: !R/Rect, x: T, y: T) {
    return r.x <= x
       and r.x + r.width >= x
       and r.y <= y
       and r.y + r.height >= y;
}

type Message struct {
    name: []i8,
    data: *none
}

type Receiver struct {
    name: []i8,
    handle: fn(form: Form, formData: *none, messageData: *none) none
}

type Form struct {
    rect: Rect!(f64),

    receivers: buf.Buffer!(Receiver),

    data: *none
}

#context forms: buf.Buffer!(Form)
#context formDatas: basic.Region

#context mousers: buf.Buffer!(Form)

fn makeForm(r: Rect!(f64), data: !T) {
    xScale := cast(f64) context.sdl.surface.w / context.sdl.xScale;
    yScale := cast(f64) context.sdl.surface.h / context.sdl.yScale;

    scaled: Rect!(f64) = {r.x * xScale, r.y * yScale, r.width * xScale, r.height * yScale};

    f: Form;

    f.rect = scaled;
    f.receivers = buf.make!(Receiver)();

    f.data = context.formDatas.current;
    dataCopy := data;
    mem.memcpy(context.formDatas.current, &dataCopy, sizeof(T));
    context.formDatas.current += sizeof(T);

    return f;
}

fn sendMessage(form: Form, message: Message) {
    for r: form.receivers.buf {
        if io.streq(message.name, r.name) {
            r.handle(form, form.data, message.data);
        }
    }
}

fn drawAllForms() {
    for form: context.forms.buf {
        sendMessage(form, {DRAW, nil});
    }

    commit();
}

#context sdl: struct {
    window: *sdl.Window,
    surface: *sdl.Surface,
    renderer: *sdl.Renderer,

    texture: *sdl.Texture,
    pixels: *none,
    pitch: i32,

    windowWidth: i32,
    windowHeight: i32,

    rendererWidth: i32,
    rendererHeight: i32,

    xScale: f64,
    yScale: f64,
}

#context cairo: struct {
    font: *cairo.FontFace,

    surface: *cairo.Surface,
    context: *cairo.Context,
    pattern: *cairo.Pattern,
}

fn initSdl() {
    err := sdl.SDL_Init(sdl.INIT_VIDEO);
    if err != 0 {
        io.println("failed to init SDL");
        panic();
    }

    window := sdl.SDL_CreateWindow("text"|io.cstr,
        sdl.WINDOWPOS_UNDEFINED, sdl.WINDOWPOS_UNDEFINED,
        WIDTH, HEIGHT,
        8196);
    if window == nil {
        io.println("failed to create window");
        panic();
    }

    context.sdl.window = window;

    sdlRenderFlags: i32 = 6;
    context.sdl.renderer = sdl.SDL_CreateRenderer(context.sdl.window, -1, sdlRenderFlags);

    -- Compute screen resolution
    -- For instance, on a retina screen, renderer size is twice as window size
    sdl.SDL_GetWindowSize(context.sdl.window, &context.sdl.windowWidth, &context.sdl.windowHeight);

    sdl.SDL_GetRendererOutputSize(context.sdl.renderer, &context.sdl.rendererWidth, &context.sdl.rendererHeight);

    -- Create a SDL surface for Cairo to render onto
    context.sdl.surface = sdl.SDL_CreateRGBSurface(
            0,
            context.sdl.rendererWidth,
            context.sdl.rendererHeight,
            32,
            0x00ff0000,
            0x0000ff00,
            0x000000ff,
            0
    );

    context.sdl.texture = sdl.SDL_CreateTexture(context.sdl.renderer,
        sdl.PIXEL_FORMAT_ARGB8888,
        sdl.TextureAccess.STREAMING,
        context.sdl.rendererWidth, context.sdl.rendererHeight);

    sdl.SDL_LockTexture(context.sdl.texture, nil, &context.sdl.pixels, &context.sdl.pitch);

    context.sdl.xScale = cast(f64) context.sdl.rendererWidth / cast(f64) context.sdl.windowWidth;
    context.sdl.yScale = cast(f64) context.sdl.rendererHeight / cast(f64) context.sdl.windowHeight;
}

fn initCairo() {
    -- Get Cairo surface form SDL2 surface
    context.cairo.surface = cairo.cairo_image_surface_create_for_data(
            cast() context.sdl.pixels,
            cairo.FORMAT_RGB24,
            context.sdl.surface.w,
            context.sdl.surface.h,
            context.sdl.surface.pitch);

    context.cairo.context = cairo.cairo_create(context.cairo.surface);
    context.cairo.pattern = cairo.cairo_pattern_create_for_surface(context.cairo.surface);

    cairo.cairo_surface_set_device_scale(context.cairo.surface, context.sdl.xScale, context.sdl.yScale);
}

fn initContext() {
    #import "mem";

    -- start with 1MB
    -- todo(chad): make this auto-expanding
    size := 1024 * 1024;

    context.formDatas.count = size;
    context.formDatas.data = mem.calloc(size, sizeof(i8));
    context.formDatas.current = context.formDatas.data;
}

fn init() {
    initContext();
    initSdl();
    initCairo();
}

fn drawRect(form: Form, rect: Rect!(f64), r: f64, g: f64, b: f64, a: f64 = 1) {
    cairo.cairo_save(context.cairo.context);
    defer { cairo.cairo_restore(context.cairo.context); }

    cairo.cairo_set_source_rgba(context.cairo.context, r, g, b, a);
    cairo.cairo_rectangle(context.cairo.context, rect.x, rect.y, rect.width, rect.height);
    cairo.cairo_fill(context.cairo.context);
}

fn commit() {
    -- Render SDL2 surface onto SDL2 renderer
    sdl.SDL_UpdateTexture(context.sdl.texture, nil, context.sdl.pixels, context.sdl.pitch);
    sdl.SDL_RenderCopy(context.sdl.renderer, context.sdl.texture, nil, nil);
    sdl.SDL_RenderPresent(context.sdl.renderer);
}

fn shutdown() {
    cairo.cairo_surface_destroy(context.cairo.surface);
    cairo.cairo_destroy(context.cairo.context);

    sdl.SDL_FreeSurface(context.sdl.surface);
    sdl.SDL_Quit();
}

fn clear() {
    cairo.cairo_set_source_rgba(context.cairo.context, 0, 0, 0, 1);
    cairo.cairo_rectangle(context.cairo.context, 0, 0, cast() context.sdl.surface.w, cast() context.sdl.surface.h);
    cairo.cairo_fill(context.cairo.context);
}
