fn glfwInit() i32
fn glfwWindowHint(hint: i32, value: i32) none
fn glfwCreateWindow(width: i32, height: i32, title: *i8, monitor: *i32, share: *i32) *none
fn glfwSwapBuffers(window: *none) none
fn glfwPollEvents() none
fn glfwMakeContextCurrent(window: *none) none
fn glViewport(x: i32, y: i32, width: i32, height: i32) none
fn glfwSetFramebufferSizeCallback(window: *none, framebuffer_size_callback: fn(window: *none, width: i32, height: i32) none) none
fn glfwSetInputMode(window: *none, mode: i32, value: i32) none
fn glfwSetCursorPosCallback(window: *none, mouse_callback: fn(window: *none, xpos: f64, ypos: f64) none) none
fn glfwSetScrollCallback(window: *none, scroll_callback: fn(window: *none, xpos: f64, ypos: f64) none) none 
fn glGenVertexArrays(count: i32, ptr: *i32) none
fn glGenBuffers(count: i32, ptr: *i32) none
fn glBindVertexArray(vao: i32) none
fn glBindBuffer(target: i32, buffer: i32) none
fn glBufferData(target: i32, size: i32, data: *none, usage: i32) none
fn glVertexAttribPointer(index: i32, size: i32, glType: i32, normalized: i8, stride: i32, data: i32) none
fn glEnableVertexAttribArray(index: i32) none
fn glGenTextures(n: i32, textures: *none) none
fn glBindTexture(target: i32, texture: i32) none
fn glTexParameteri(target: i32, pname: i32, param: i32) none
fn stbi_load(filename: *i8, x: *i32, y: *i32, channels_in_file: *i32, desired_channels: i32) *i8
fn glTexImage2D(target: i32, level: i32, internalformat: i32, width: i32, height: i32, border: i32, format: i32, glType: i32, pixels: *i8) none
fn glGenerateMipmap(n: i32) none
fn glCompileShader(n: i32) none
fn glShaderSource(shader: i32, count: i32, src: **i8, length: *none) none
fn glCreateShader(shaderType: i32) i32
fn glAttachShader(ID: i32, program: i32) none
fn glLinkProgram(ID: i32) none
fn glUseProgram(ID: i32) none
fn glDeleteShader(program: i32) none
fn glCreateProgram() i32
fn glGetUniformLocation(program: i32, name: *i8) i32
fn glUniform1i(location: i32, v0: i32) none
fn glEnable(cap: i32) none
fn glfwGetTime() f64
fn glClearColor(r: f32, g: f32, b: f32, a: f32) none
fn glClear(bf: i32) none
fn glUniformMatrix4fv(location: i32, count: i32, transpose: i8, value: *f32) none
fn glActiveTexture(texture: i32) none
fn glDrawArrays(mode: i32, first: i32, count: i32) none
fn glGetShaderiv(program: i32, pname: i32, params: *i32) none
fn glGetProgramiv(program: i32, pname: i32, params: *i32) none

fn stbi_image_free(data: *i8) none

fn puts(str: *i8) none
fn putstr(s: []i8) {
	puts(s.data);
	ret 0;
}

fn gl_main(window: *none, shaderProgram: i32, vertices: *f32) i32

type Mat4 struct {
    a0_0:  f32, a0_1:  f32,  a0_2: f32, a0_3:  f32,
    a1_0:  f32, a1_1:  f32,  a1_2: f32, a1_3:  f32,
    a2_0:  f32, a2_1:  f32,  a2_2: f32, a2_3:  f32,
    a3_0:  f32, a3_1:  f32,  a3_2: f32, a3_3:  f32,
}

type Vec3 struct {
    x: f32,
    y: f32,
    z: f32,
}

fn sqrtf(f: f32) f32
fn sinf(f: f32) f32
fn cosf(f: f32) f32
fn tanf(f: f32) f32

fn radians(degrees: f32) f32

fn vec3_normalize(v: Vec3) Vec3
fn vec3_muls(v: Vec3, s: f32) Vec3
fn vec3_add(a: Vec3, b: Vec3) Vec3
fn vec3_sub(a: Vec3, b: Vec3) Vec3
fn vec3_cross(a: Vec3, b: Vec3) Vec3

fn mat4_id() Mat4
fn mat4_mul(a: Mat4, b: Mat4) Mat4
fn mat4_perspective(fovy: f32, aspect: f32, zNear: f32, zFar: f32) Mat4
fn mat4_translate(v: Vec3) Mat4
fn mat4_rotate(v: Vec3) Mat4
fn mat4_look_at(pos: Vec3, target: Vec3, worldUp: Vec3) Mat4

-- fn radians(degrees: f32) {
    -- ret degrees / 360.0 * 2.0 * 3.1415926535;
-- }

-- fn vec3_normalize(v: Vec3) Vec3 {
    -- magnitude := sqrtf(v.x * v.x + v.y * v.y + v.z * v.z);
    -- ret { v.x / magnitude, v.y / magnitude, v.z / magnitude };
-- }

-- fn vec3_muls(v: Vec3, s: f32) Vec3 {
    -- ret { v.x * s, v.y * s, v.z * s };
-- }

-- fn vec3_add(a: Vec3, b: Vec3) Vec3 {
    -- ret { a.x + b.x, a.y + b.y, a.z + b.z };
-- }

-- fn vec3_sub(a: Vec3, b: Vec3) Vec3 {
    -- ret { a.x - b.x, a.y - b.y, a.z - b.z };
-- }

-- fn vec3_cross(a: Vec3, b: Vec3) Vec3 {
    -- ret { a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x };
-- }

-- fn mat4_zeroes() Mat4 {
    -- ret {
        -- 0.0, 0.0, 0.0, 0.0,
        -- 0.0, 0.0, 0.0, 0.0,
        -- 0.0, 0.0, 0.0, 0.0,
        -- 0.0, 0.0, 0.0, 0.0
    -- };
-- }

-- fn mat4_id() Mat4 {
    -- ret {
        -- 1.0, 0.0, 0.0, 0.0,
        -- 0.0, 1.0, 0.0, 0.0,
        -- 0.0, 0.0, 1.0, 0.0,
        -- 0.0, 0.0, 0.0, 1.0
    -- };
-- }

-- fn mat4_mul(a: Mat4, b: Mat4) {
    -- m := mat4_zeroes();
    -- fm := cast(*f32) &m;

    -- i := 0;
    -- while i < 16 {
        -- ^(fm + (i * 4)) = 0.0;
        -- i = i + 1;
    -- }

    -- fa := cast(*f32) &a;
    -- fb := cast(*f32) &b;

    -- i = 0;
    -- while i < 4 {
        -- j := 0;
        -- while j < 4 {
            -- k := 0;
            -- while k < 4 {
                -- aik := ^(fa + ((i * 4) + k) * 4);
                -- bkj := ^(fb + ((k * 4) + j) * 4);
                -- rij := fm + ((i * 4) + j) * 4;
                -- ^rij = ^rij + (aik * bkj);

                -- k = k + 1;
            -- }

            -- j = j + 1;
        -- }

        -- i = i + 1;
    -- }

    -- ret m;
-- }

-- fn mat4_perspective(fovy: f32, aspect: f32, zNear: f32, zFar: f32) {
    -- f := 1.0 / tan(fovy * 0.5);

    -- r := mat4_zeroes();
    -- fr := cast(*f32) &r;

    -- ^fr = f / aspect;
    -- ^(fr + (4 + 1) * 4) = f;
    -- ^(fr + (8 + 2) * 4) = (zFar + zNear) / (zNear - zFar);
    -- ^(fr + (8 + 3) * 4) = -1.0;
    -- ^(fr + (12 + 2) * 4) = (2.0 * zFar * zNear) / (zNear - zFar);

    -- ret r;
-- }

-- fn mat4_translate(v: Vec3) {
    -- r := mat4_id();
    -- fr := cast(*f32) &r;

    -- ^(fr + 12 * 4) = v.x;
    -- ^(fr + (12 + 1) * 4) = v.y;
    -- ^(fr + (12 + 2) * 4) = v.z;

    -- ret r;
-- }

-- fn mat4_rotate(v: Vec3) {
    -- r := mat4_zeroes();
    -- fr := cast(*f32) &r;

    -- A       := cos(v.x);
    -- B       := sin(v.x);
    -- C       := cos(v.y);
    -- D       := sin(v.y);
    -- E       := cos(v.z);
    -- F       := sin(v.z);

    -- ^fr  =  C * E;
    -- ^(fr + 1 * 4)  = -C * F;
    -- ^(fr + 2 * 4)  = -D;
    -- ^(fr + 4 * 4)  = -B * D * E + A * F;
    -- ^(fr + 5 * 4)  =  B * D * F + A * E;
    -- ^(fr + 6 * 4)  = -B * C;
    -- ^(fr + 8 * 4)  =  A * D * E + B * F;
    -- ^(fr + 9 * 4)  = -A * D * F + B * E;
    -- ^(fr + 10 * 4) =  A * C;

    -- ^(fr + 3 * 4) = 0.0;
    -- ^(fr + 7 * 4) = 0.0;
    -- ^(fr + 11 * 4) = 0.0;
    -- ^(fr + 12 * 4) = 0.0;
    -- ^(fr + 13 * 4) = 0.0;
    -- ^(fr + 14 * 4) = 0.0;

    -- ^(fr + 15 * 4) =  1.0;

    -- ret r;
-- }

-- fn mat4_look_at(pos: Vec3, target: Vec3, worldUp: Vec3) {
    -- cameraDirection
    -- zaxis := vec3_normalize(vec3_sub(pos, target));

    -- positive right axis vector
    -- xaxis := vec3_normalize(vec3_cross(vec3_normalize(worldUp), zaxis));

    -- camera up vector
    -- yaxis := vec3_cross(zaxis, xaxis);

    -- translation
    -- translation := mat4_id();
    -- ftranslation := cast(*f32) &translation;
    -- ^(ftranslation + 12 * 4) = -pos.x;
    -- ^(ftranslation + (12 + 1) * 4) = -pos.y;
    -- ^(ftranslation + (12 + 2) * 4) = -pos.z;

    -- rotation
    -- rotation := mat4_id();
    -- frotation := cast(*f32) &rotation;
    -- ^(frotation) = xaxis.x;
    -- ^(frotation + 4 * 4) = xaxis.y;
    -- ^(frotation + 8 * 4) = xaxis.z;
    -- ^(frotation + 1 * 4) = yaxis.x;
    -- ^(frotation + (4 + 1) * 4) = yaxis.y;
    -- ^(frotation + (8 + 1) * 4) = yaxis.z;
    -- ^(frotation + 2 * 4) = zaxis.x;
    -- ^(frotation + (4 + 2) * 4) = zaxis.y;
    -- ^(frotation + (8 + 2) * 4) = zaxis.z;

    -- ret mat4_mul(rotation, translation);
-- }

fn setupTexture(imageFilePath: *i8, includeAlpha: i32) {
    GL_TEXTURE_2D: i32 = 3553;
    GL_TEXTURE_WRAP_S: i32 = 10242;
    GL_TEXTURE_WRAP_T: i32 = 10243;
    GL_REPEAT: i32 = 10497;
    GL_LINEAR: i32 = 9729;
    GL_TEXTURE_MIN_FILTER: i32 = 10241;
    GL_TEXTURE_MAG_FILTER: i32 = 10240;
    GL_UNSIGNED_BYTE: i32 = 5121;
    GL_RGB: i32 = 6407;
    GL_RGBA: i32 = 6408;

    texture: i32;
    glGenTextures(1, &texture);
    glBindTexture(GL_TEXTURE_2D, texture);

    -- set the texture wrapping/filtering options (on the currently bound texture object)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

    width: i32;
    height: i32;
    nrChannels: i32;
    data := stbi_load(imageFilePath, &width, &height, &nrChannels, 0);

    format := GL_RGB;
    if includeAlpha == 1 {
         format = GL_RGBA;
    }
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, format, GL_UNSIGNED_BYTE, data);
    glGenerateMipmap(GL_TEXTURE_2D);

    stbi_image_free(data);

    ret texture;
}

fn c_main(window: *none) none

fn main() {
    GLFW_CONTEXT_VERSION_MAJOR : i32 = 139266;
    GLFW_CONTEXT_VERSION_MINOR : i32 = 139267;
    GLFW_OPENGL_PROFILE : i32 = 139272;
    GLFW_OPENGL_CORE_PROFILE : i32 = 204801;
    GLFW_OPENGL_FORWARD_COMPAT : i32 = 139270;
	GLFW_CURSOR : i32 = 208897;
	GLFW_CURSOR_DISABLED : i32 = 212995;
	GL_ARRAY_BUFFER : i32 = 34962;
	GL_STATIC_DRAW : i32 = 35044;
	GL_FLOAT : i32 = 5126;
    GL_DEPTH_TEST : i32 = 2929;
    GL_DEPTH_BUFFER_BIT : i32 = 256;
    GL_COLOR_BUFFER_BIT : i32 = 16384;
    GL_COLOR_OR_DEPTH_BUFFER_BIT : i32 = 16640;
    GL_TEXTURE0 : i32 = 33984;
    GL_TEXTURE1 : i32 = 33985;
    GL_TEXTURE_2D : i32 = 3553;
    GL_TRIANGLES : i32 = 4;

	GL_TRUE : i8 = 1;
	GL_FALSE : i8 = 0;

    SCR_WIDTH : i32 = 800;
    SCR_HEIGHT : i32 = 600;

    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, 1);

    window := glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "wb\0".data, nil, nil);
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    c_main(window);

    float_size : i32 = 4;

	vertices := cast(*f32) &{
		-0.5, -0.5, -0.5,  0.0, 0.0,
		0.5, -0.5, -0.5,  1.0, 0.0,
		0.5,  0.5, -0.5,  1.0, 1.0,
		0.5,  0.5, -0.5,  1.0, 1.0,
		-0.5,  0.5, -0.5,  0.0, 1.0,
		-0.5, -0.5, -0.5,  0.0, 0.0,

		-0.5, -0.5,  0.5,  0.0, 0.0,
		0.5, -0.5,  0.5,  1.0, 0.0,
		0.5,  0.5,  0.5,  1.0, 1.0,
		0.5,  0.5,  0.5,  1.0, 1.0,
		-0.5,  0.5,  0.5,  0.0, 1.0,
		-0.5, -0.5,  0.5,  0.0, 0.0,

		-0.5,  0.5,  0.5,  1.0, 0.0,
		-0.5,  0.5, -0.5,  1.0, 1.0,
		-0.5, -0.5, -0.5,  0.0, 1.0,
		-0.5, -0.5, -0.5,  0.0, 1.0,
		-0.5, -0.5,  0.5,  0.0, 0.0,
		-0.5,  0.5,  0.5,  1.0, 0.0,

		0.5,  0.5,  0.5,  1.0, 0.0,
		0.5,  0.5, -0.5,  1.0, 1.0,
		0.5, -0.5, -0.5,  0.0, 1.0,
		0.5, -0.5, -0.5,  0.0, 1.0,
		0.5, -0.5,  0.5,  0.0, 0.0,
		0.5,  0.5,  0.5,  1.0, 0.0,

		-0.5, -0.5, -0.5,  0.0, 1.0,
		0.5, -0.5, -0.5,  1.0, 1.0,
		0.5, -0.5,  0.5,  1.0, 0.0,
		0.5, -0.5,  0.5,  1.0, 0.0,
		-0.5, -0.5,  0.5,  0.0, 0.0,
		-0.5, -0.5, -0.5,  0.0, 1.0,

		-0.5,  0.5, -0.5,  0.0, 1.0,
		0.5,  0.5, -0.5,  1.0, 1.0,
		0.5,  0.5,  0.5,  1.0, 0.0,
		0.5,  0.5,  0.5,  1.0, 0.0,
		-0.5,  0.5,  0.5,  0.0, 0.0,
		-0.5,  0.5, -0.5,  0.0, 1.0
	};
	vertices_count : i32 = 180;
    size_of_vertices : i32 = vertices_count * float_size;

    VBO: i32;
    VAO: i32;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);

    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, size_of_vertices, cast(*none) vertices, GL_STATIC_DRAW);

    -- position attribute
    position_stride : i32 = 5;
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, position_stride * float_size, 0);
    glEnableVertexAttribArray(0);

    -- texture coord attribute
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, position_stride * float_size, 3 * float_size);
    glEnableVertexAttribArray(1);

    -- texture1 := setupTexture(cast(*i8) "/Users/chadrussell/Pictures/container.jpg\0".data, 0);
    -- texture2 := setupTexture(cast(*i8) "/Users/chadrussell/Pictures/awesomeface.png\0".data, 1);

    -- shaderProgram := setup_shaders();
    -- glUseProgram(shaderProgram);
    -- glUniform1i(glGetUniformLocation(shaderProgram, "texture1\0".data), 0);
    -- glUniform1i(glGetUniformLocation(shaderProgram, "texture2\0".data), 1);

    cubePositions : []Vec3 = {
        data: cast(*Vec3) &{
            { 0.0,  0.0,  0.0 },
            { 2.0,  5.0, -15.0},
            {-1.5, -2.2, -2.5 },
            {-3.8, -2.0, -12.3},
            { 2.4, -0.4, -3.5 },
            {-1.7,  3.0, -7.5 },
            { 1.3, -2.0, -2.5 },
            { 1.5,  2.0, -2.5 },
            { 1.5,  0.2, -1.5 },
            {-1.3,  1.0, -1.5 }
        },
        count: 10
    };

    glEnable(GL_DEPTH_TEST);

    deltaTime := 0.0;
    lastFrame := 0.0;
    fov := 45.0;

    cameraPos   := {0.0, 0.0,  3.0};
    cameraFront := {0.0, 0.0, -1.0};
    cameraUp    := {0.0, 1.0,  0.0};

    while true {

        -- currentFrame := glfwGetTime();
        -- deltaTime = currentFrame - lastFrame;
        -- lastFrame = currentFrame;

        -- process_input(window);

		-- glClearColor(0.2, 0.3, 0.3, 1.0);
        -- glClear(GL_COLOR_OR_DEPTH_BUFFER_BIT);

        -- projection := mat4_perspective(radians(fov), 800.0 / 600.0, 0.1, 100.0);
        -- glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "projection\0".data), 1, GL_FALSE, cast(*f32) &projection);

        -- view := mat4_look_at(cameraPos, vec3_add(cameraPos, cameraFront), cameraUp);
        -- glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "view\0".data), 1, GL_FALSE, cast(*f32) &view);

        -- glActiveTexture(GL_TEXTURE0);
        -- glBindTexture(GL_TEXTURE_2D, texture1);
        -- glActiveTexture(GL_TEXTURE1);
        -- glBindTexture(GL_TEXTURE_2D, texture2);

        -- glBindVertexArray(VAO);
        -- idx := 0;
        -- idxf := 0.0;
        -- while idx < 10 {
            -- model := mat4_id();
            -- model := mat4_translate(cubePositions[idx]);

            -- angle := 20.0 * (idxf + 1.0);
            -- angle = radians(angle);
            -- r := mat4_rotate({angle / 8.0, angle / 8.0, angle / 16.0});
            -- model = mat4_mul(r, model);

            -- glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "model\0".data), 1, GL_FALSE, cast(*f32) &model);

            -- glDrawArrays(GL_TRIANGLES, 0, 36);

            -- idx = idx + 1;
        -- }

        -- glfwSwapBuffers(window);
        -- glfwPollEvents();
    }

    ret 0;
}

fn setup_shaders() {
    fss := "
        #version 330 core
        out vec4 FragColor;

        in vec2 texCoord;

        uniform sampler2D texture1;
        uniform sampler2D texture2;

        void main()
        {
        	FragColor = mix(texture(texture1, texCoord), texture(texture2, texCoord), 0.2);
        }
    \0";

    vss := "
        #version 330 core
        layout (location = 0) in vec3 aPos;
        layout (location = 1) in vec2 aTexCoord;

        out vec2 texCoord;

        uniform mat4 model;
        uniform mat4 view;
        uniform mat4 projection;

        void main()
        {
            texCoord = aTexCoord;
            gl_Position = projection * view * model * vec4(aPos, 1.0f);
        }
    \0";

    GL_VERTEX_SHADER: i32 = 35633;
    GL_FRAGMENT_SHADER: i32 = 35632;
    GL_COMPILE_STATUS : i32 = 35713;
    GL_LINK_STATUS : i32 = 35714;

    vertex: i32;
    fragment: i32;
    success: i32;
    
    -- vertex shader
    vertex = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertex, 1, &vss.data, nil);
    glCompileShader(vertex);
    glGetShaderiv(vertex, GL_COMPILE_STATUS, &success);
    if (success == 0) {
        putstr("vertex shader compilation failed!!!");
    }

    -- fragment Shader
    fragment = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragment, 1, &fss.data, nil);
    glCompileShader(fragment);
    glGetShaderiv(fragment, GL_COMPILE_STATUS, &success);
    if (success == 0) {
        putstr("fragment shader compilation failed!!!");
    }

    id := glCreateProgram();
    glAttachShader(id, vertex);
    glAttachShader(id, fragment);
    glLinkProgram(id);
    glGetProgramiv(id, GL_LINK_STATUS, &success);
    if(success == 0) {
        putstr("shader linking failed!!");
    }

    glDeleteShader(vertex);
    glDeleteShader(fragment);

    ret id;
}

fn framebuffer_size_callback(window: *none, width: i32, height: i32) {
	-- make sure the viewport matches the new window dimensions; note that width and 
	-- height will be significantly larger than specified on retina displays.
	glViewport(0, 0, width, height);
	putstr("framebuffer size changed\0");

	ret 0;
}

fn mouse_callback(window: *none, xpos: f64, ypos: f64) {
	-- todo(chad): ya know, actually put shit here
	putstr("mouse callback!\0");
    
    ret 0;
}

fn scroll_callback(window: *none, xoffset: f64, yoffset: f64) {
	-- todo(chad): ya know, actually put shit here
	putstr("scroll callback!\0");

    ret 0;
}
