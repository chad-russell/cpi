#import "gui/gui";
#import "gui/text";
#import "io";
#import "buffer": buf;
#import "sdl";
#import "cairo";
#import "math";
#import "iter";

NODE_RADIUS: f64 = 3;

#context state: struct {
    scale: f64,

    entities: buf.Buffer!(EID),
    nodes: buf.Buffer!(Node),
    ports: buf.Buffer!(Port),
    connections: buf.Buffer!(Connection),

    transformedMouse: gui.Point!(f64),

    mouseDownStart: gui.Point!(f64),
    mouseDown := false,

    canvasBeingDragged := false,
    dragging := false,

    nodeBeingDragged: EID = 0,
    portBeingDragged: EID = 0,
    tentativeConnection: EID = 0,
}

-- todo(chad): rename me!
type EID u64

type SizeComponent struct {
    width: f64,
    height: f64,
}

type type PositionComponent struct {
    x: f64,
    y: f64,
}

type Node struct {
    rect: gui.Rect,
    active: bool,

    inputs: buf.Buffer!(Port),
    outputs: buf.Buffer!(Port),
}

type Port struct {
    isInput: bool,
    center: gui.Point!(f64),
}

type Connection struct {
    from: EID,
    to: EID,
}

fn makeEID() {
    newId := cast(u64) context.state.entities.buf.count + 1;
    &context.state.entities|:append(newId);
    return newId;
}

fn init() {
    basic.initContext();

    gui.init();

    text.init();

    context.state.scale = 1.0;

    while !context.quit {
        gui.tick();

        processMessages();
        draw(gui.windowRect());

        gui.commit();
    }

    return 0;
}

fn processMessages() {
    tmp_scale();
    defer { cairo.cairo_restore(context.cairo.layer.context); }

    if context.keyDownEvent != nil {
        keydown(context.keyDownEvent);
    }
    if context.mouseMotionEvent != nil {
        mouseMove(context.mouseMotionEvent);
    }
    if context.mouseButtonDownEvent != nil {
        mouseButtonDown(context.mouseButtonDownEvent);
    }
    if context.mouseButtonUpEvent != nil {
        mouseButtonUp(context.mouseButtonUpEvent);
    }
}

fn checkMouseDownInPort(node: *Node, port: Port) {
    if gui.distance(port.center, context.state.transformedMouse) < magFactor(port) * 3 {
        alreadyInConnection := false;
        c: Connection;
        cIndex: i64;

        for connection, i: context.state.connections.buf {
            if connection.from == node.id or connection.to == node.id {
                alreadyInConnection = true;
                c = connection;
                cIndex = i;
            }
        }

        if alreadyInConnection == true {
            -- todo(chad): This is overkill. Just delete by reordering...
            &context.state.connections|:buf.deleteInPlace(cIndex);

            if c.from == node.id {
                context.state.portBeingDragged = c.to;
            }
            else {
                context.state.portBeingDragged = c.from;
            }
        }
        else {
            context.state.nodeBeingDragged = 0;
            context.state.portBeingDragged = node.id;
        }
    }
}

fn mouseButtonDown(messageData: *sdl.MouseButtonEvent) {
    context.state.mouseDownStart = context.state.transformedMouse;
    context.state.mouseDown = true;
    context.state.dragging = false;

    context.state.nodeBeingDragged = 0;
    context.state.portBeingDragged = 0;

    for node: context.state.nodes.buf|iter.byRef {
        mouseDownInPort := false;
        for port, index: node.inputs.buf {
            checkMouseDownInPort(node, node.inputs.buf[index]);
        }
        for port, index: node.outputs.buf {
            checkMouseDownInPort(node, node.outputs.buf[index]);
        }

        if mouseDownInPort == false and node.rect|gui.contains(context.state.transformedMouse.x, context.state.transformedMouse.y) {
            context.state.nodeBeingDragged = node.id;
        }
    }
}

fn mouseMove(messageData: *sdl.MouseMotionEvent) {
    context.state.transformedMouse = context.mouse;
    cairo.cairo_device_to_user(context.cairo.layer.context, &context.state.transformedMouse.x, &context.state.transformedMouse.y);

    dx := context.state.transformedMouse.x - context.state.mouseDownStart.x;
    dy := context.state.transformedMouse.y - context.state.mouseDownStart.y;

    if context.state.mouseDown {
        context.state.dragging = true;
        context.state.mouseDownStart = context.state.transformedMouse;
    }

    context.state.tentativeConnection = 0;
    if context.state.portBeingDragged != 0 {
        -- establish a connection?
        -- for node: context.state.nodes.buf|iter.byRef {
            -- pc := portCenter(node);
            -- mf := magFactor(node);

            -- if node.id != context.state.portBeingDragged and gui.distance(context.state.transformedMouse, pc) < NODE_RADIUS * mf {
                -- context.state.tentativeConnection = node.id;
            -- }
        -- }
    }
    else if context.state.nodeBeingDragged != 0 {
        nbd := findNode(context.state.nodeBeingDragged);

        nbd.active = true;
        nbd.rect.x += dx;
        nbd.rect.y += dy;
    }
    else if context.state.mouseDown {
        context.state.canvasBeingDragged = true;

        for node: context.state.nodes.buf|iter.byRef {
            node.rect.x += dx;
            node.rect.y += dy;
        }
    }
    else {
        for node: context.state.nodes.buf|iter.byRef {
            if node.rect|gui.contains(context.state.transformedMouse.x, context.state.transformedMouse.y) {
                node.active = true;
            }
            else {
                node.active = false;
            }
        }
    }
}

fn mouseButtonUp(messageData: *sdl.MouseButtonEvent) {
    context.state.mouseDown = false;
    context.state.nodeBeingDragged = 0;
    context.state.canvasBeingDragged = false;

    if context.state.tentativeConnection != 0 {
        &context.state.connections|:append({
            id: makeEID(),
            from: context.state.portBeingDragged,
            to: context.state.tentativeConnection,
        });

        context.state.tentativeConnection = 0;
    }
    else if context.state.dragging == false {
        -- make a new node
        n: Node;
        n.id = makeEID();
        n.rect = {context.state.transformedMouse.x, context.state.transformedMouse.y, 200, 100};
        n.active = true;

        &context.state.nodes|:append(n);
    }

    context.state.portBeingDragged = 0;

    context.state.dragging = false;
}

fn keydown(messageData: *sdl.KeyboardEvent) {
    if messageData.keysym.scancode == sdl.Key.SPACE {
        io.println("space");
    }
    else if messageData.keysym.scancode == sdl.Key.LEFT {
        io.println("left");
    }
}

fn tmp_scale() {
    if context.modifierKeys.shift {
        diff := context.state.scale - 1.5;
        context.state.scale -= diff / 2;
    }
    else {
        diff := 1.0 - context.state.scale;
        context.state.scale += diff / 2;
    }

    cairo.cairo_save(context.cairo.layer.context);
    cairo.cairo_scale(context.cairo.layer.context, context.state.scale, context.state.scale);
}

fn findNode(EID: EID) {
    basic.assert(EID >= 0 and EID <= cast(u64) context.state.nodes.buf.count);
    return &context.state.nodes.buf[EID - 1];
}

fn magFactor(port: Port) {
    mf: f64 = 1.0;

    dist := gui.distance(port.center, context.state.transformedMouse);
    if dist < 20 {
        dist /= 10;
        mf = math.min(5 - (dist * dist), 2.5);
    }

    return mf;
}

fn drawNode(node: *Node) {
    fontSize: f64 = 78;

    nodeColor: gui.Color = {cast(f64) 167.0/255.0, cast(f64) 98.0/255.0, cast(f64) 82.0/255.0};
    if node.active == true or context.state.canvasBeingDragged == true {
        nodeColor = {cast(f64) 98.0/255.0, cast(f64) 167.0/255.0, cast(f64) 82.0/255.0};
    }

    gui.drawRoundedRect(context.cairo.layer,
        node.rect,
        nodeColor.r, nodeColor.g, nodeColor.b,
        radius: NODE_RADIUS, lineWidth: 5);


    -- draw ports
    for port: node.inputs.buf {
        pc := port.center;
        mf := magFactor(port);

        gui.drawCircle(context.cairo.layer,
            pc,
            NODE_RADIUS * mf,
            nodeColor.r, nodeColor.g, nodeColor.b,
            lineWidth: 1);
    }
    for port: node.outputs.buf {

    }

    -- text.drawBoundedText("0.5", bounds: {node.rect.x + node.rect.width/2, node.rect.y, node.rect.width/2 - 5, node.rect.height});
}

fn drawConnection(connection: Connection) {
    p1 := findNode(connection.from).inputs.buf[connection.fromIndex].center;
    p2 := findNode(connection.to).inputs.buf[connection.toIndex].center;

    gui.drawCurve(context.cairo.layer,
        p1: p1,
        p2: p2,
        cp1: cast() {
            x: gui.lerp(p1.x, p2.x, 0.3),
            y: p1.y,
        },
        cp2: cast() {
            x: gui.lerp(p1.x, p2.x, 0.7),
            y: p2.y,
        },
        color: {
            r: cast() 250.0/255.0,
            g: cast() 215.0/255.0,
            b: cast() 0.0/255.0,
        },
        width: 4,
    );
}

fn draw(rect: gui.Rect) {
    -- background
    gui.drawRect(context.cairo.layer, rect, cast(f64) 67.0/255.0, cast(f64) 77.0/255.0, cast(f64) 82.0/255.0);

    tmp_scale();
    defer { cairo.cairo_restore(context.cairo.layer.context); }

    -- connections
    for connection: context.state.connections.buf {
        drawConnection(connection);
    }
    if context.state.portBeingDragged != 0 {
        -- todo(chad): why can't you drag from output -> input?
        pc := findNode(context.state.portBeingDragged).inputs.buf[context.state.portBeingDraggedIndex].center;

        p1 := pc;
        p2 := context.state.transformedMouse;

        cp1: gui.Point!(f64) = {gui.lerp(p1.x, p2.x, 0.3), p1.y};
        cp2: gui.Point!(f64) = {gui.lerp(p1.x, p2.x, 0.7), p2.y};

        color: gui.Color = {
            r: cast(f64) 250.0/255.0,
            g: cast(f64) 215.0/255.0,
            b: cast(f64) 0.0/255.0,
        };

        gui.drawCurve(context.cairo.layer,
            p1: p1,
            p2: p2,
            cp1: cp1,
            cp2: cp2,
            color: color,
            width: 4,
        );
    }

    -- nodes
    for node: context.state.nodes.buf|iter.byRef {
        drawNode(node);
    }
}
