#import "gui/gui";
#import "gui/text";
#import "io";
#import "buffer": buf;
#import "sdl";
#import "cairo";
#import "math";
#import "iter";

PORT_RADIUS: f64 = 3;

type EID i64

#context state: struct {
    scale: f64,

    nodes: buf.Buffer!(Node),
    ports: buf.Buffer!(Port),

    connections: buf.Buffer!(Connection),

    transformedMouse: gui.Point!(f64),

    mouseDownStart: gui.Point!(f64),
    mouseDown := false,

    canvasBeingDragged := false,
    dragging := false,

    nodeBeingDragged: EID = -1,
    portBeingDragged: EID = -1,
    tentativeConnection: EID = -1,
}

type Node struct {
    valid: bool,

    rect: gui.Rect,
    active: bool,

    inputs: buf.Buffer!(EID),
    outputs: buf.Buffer!(EID),
}

type NodeIterator struct {
    index: i64
}

type Port struct {
    valid: bool,

    isInput: bool,
    center: gui.Point!(f64),

    connections: i32 = 0,
    allowedConnections: i32 = 1,
}

type Connection struct {
    from: EID,
    to: EID,
}

fn addNode(n: Node) EID {
    for node, index: context.state.nodes.buf {
        if node.valid == false {
            context.state.nodes.buf[index] = n;
            return index;
        }
    }

    &context.state.nodes|:append(n);
    return context.state.nodes.buf.count - 1;
}

fn addPort(p: Port) EID {
    for port, index: context.state.ports.buf {
        if port.valid == false {
            context.state.ports.buf[index] = p;
            return index;
        }
    }

    &context.state.ports|:append(p);
    return context.state.ports.buf.count - 1;
}

fn init() {
    basic.initContext();

    gui.init();

    text.init();

    context.state.scale = 1.0;

    while !context.quit {
        gui.tick();

        processMessages();
        draw(gui.windowRect());

        gui.commit();
    }

    return 0;
}

fn processMessages() {
    if context.multiGestureEvent != nil {
        context.state.scale += cast() (context.multiGestureEvent.dDist * 5);
        if context.state.scale < 0.5 {
            context.state.scale = 0.5;
        }
        if context.state.scale > 1.5 {
            context.state.scale = 1.5;
        }
    }

    tmp_scale();
    defer { cairo.cairo_restore(context.cairo.layer.context); }

    if context.keyDownEvent != nil {
        keydown(context.keyDownEvent);
    }
    if context.mouseMotionEvent != nil {
        mouseMove(context.mouseMotionEvent);
    }
    if context.mouseButtonDownEvent != nil {
        mouseButtonDown(context.mouseButtonDownEvent);
    }
    if context.mouseButtonUpEvent != nil {
        mouseButtonUp(context.mouseButtonUpEvent);
    }
}

fn checkMouseDownInPort(port: *Port, id: EID) {
    if gui.distance(port.center, context.state.transformedMouse) < magFactor(port) * PORT_RADIUS {
        alreadyInConnection := false;
        c: Connection;
        cIndex: i64;

        for connection, i: context.state.connections.buf {
            if connection.from == id or connection.to == id {
                alreadyInConnection = true;
                c = connection;
                cIndex = i;
            }
        }

        if alreadyInConnection == true {
            removeConnection(cIndex);

            if c.from == id {
                context.state.portBeingDragged = c.to;
            }
            else {
                context.state.portBeingDragged = c.from;
            }
        }
        else {
            context.state.nodeBeingDragged = -1;
            context.state.portBeingDragged = id;
        }
    }
}

fn mouseButtonDown(messageData: *sdl.MouseButtonEvent) {
    context.state.mouseDownStart = context.state.transformedMouse;
    context.state.mouseDown = true;
    context.state.dragging = false;

    context.state.nodeBeingDragged = -1;
    context.state.portBeingDragged = -1;

    mouseDownInPort := false;
    for port, index: context.state.ports.buf {
        if port.valid == true {
            checkMouseDownInPort(&port, index);
        }
    }

    if mouseDownInPort == false {
        for node, index: context.state.nodes.buf {
            if node.valid == true and node.active == true {
                context.state.nodeBeingDragged = index;
            }
        }
    }
}

fn mouseMove(messageData: *sdl.MouseMotionEvent) {
    context.state.transformedMouse = context.mouse;
    cairo.cairo_device_to_user(context.cairo.layer.context, &context.state.transformedMouse.x, &context.state.transformedMouse.y);

    dx := context.state.transformedMouse.x - context.state.mouseDownStart.x;
    dy := context.state.transformedMouse.y - context.state.mouseDownStart.y;

    if context.state.mouseDown {
        context.state.dragging = true;
        context.state.mouseDownStart = context.state.transformedMouse;
    }

    context.state.tentativeConnection = -1;
    if context.state.portBeingDragged != -1 {
        -- establish a connection?
        for port, portIndex: context.state.ports.buf {
            if port.valid == true {
                mf := magFactor(&port);

                if portIndex != context.state.portBeingDragged and gui.distance(context.state.transformedMouse, port.center) < PORT_RADIUS * mf {
                    pbd := findPort(context.state.portBeingDragged);

                    if (pbd.isInput == true and port.isInput == false) or (pbd.isInput == false and port.isInput == true) {
                        context.state.tentativeConnection = portIndex;
                    }
                }
            }
        }
    }
    else if context.state.nodeBeingDragged != -1 {
        nbd := findNode(context.state.nodeBeingDragged);

        nbd.active = true;
        nbd.rect.x += dx;
        nbd.rect.y += dy;
    }
    else if context.state.mouseDown {
        context.state.canvasBeingDragged = true;

        for node: context.state.nodes.buf|iter.byRef {
            if node.valid == true {
                node.rect.x += dx;
                node.rect.y += dy;
            }
        }
    }
    else {
        for node: context.state.nodes.buf|iter.byRef {
            if node.valid == true {
                if node.rect|gui.contains(context.state.transformedMouse.x, context.state.transformedMouse.y) {
                    node.active = true;
                }
                else {
                    node.active = false;
                }
            }
        }
    }
}

fn mouseButtonUp(messageData: *sdl.MouseButtonEvent) {
    context.state.mouseDown = false;
    context.state.canvasBeingDragged = false;

    if context.state.tentativeConnection != -1 {
        from := findPort(context.state.portBeingDragged);
        to := findPort(context.state.tentativeConnection);

        if from.connections < from.allowedConnections and to.connections < to.allowedConnections {
            from.connections += 1;
            to.connections += 1;

            &context.state.connections|:append({
                from: context.state.portBeingDragged,
                to: context.state.tentativeConnection,
            });
        }

        context.state.tentativeConnection = -1;
    }
    else if messageData.button == sdl.MouseButton.RIGHT {
        -- delete node

        valid := true;
        if context.state.nodeBeingDragged == -1 {
            valid = false;
        }

        node: *Node;
        if valid == true {
            node = findNode(context.state.nodeBeingDragged);
            valid = node.valid;
        }

        if valid {
            -- delete any connections that involve a node's inputs or outputs
            index := context.state.connections.buf.count - 1;
            while index >= 0 {
                c := context.state.connections.buf[index];
                shouldDelete := false;

                for p: node.inputs.buf {
                    if p == c.to or p == c.from {
                        shouldDelete = true;
                    }
                }
                for p: node.outputs.buf {
                    if p == c.to or p == c.from {
                        shouldDelete = true;
                    }
                }

                if shouldDelete == true {
                    removeConnection(index);
                }

                index -= 1;
            }

            -- delete ports from the node
            for p: node.inputs.buf {
                context.state.ports.buf[p].valid = false;
            }
            for p: node.outputs.buf {
                context.state.ports.buf[p].valid = false;
            }

            -- delete the node
            context.state.nodes.buf[context.state.nodeBeingDragged].valid = false;
        }
    }
    else if context.state.dragging == false {
        -- make a new node
        n: Node;
        n.valid = true;
        n.rect = {context.state.transformedMouse.x, context.state.transformedMouse.y, 200, 100};
        n.active = true;

        fn addPortToNode(n: *Node, b: *buf.Buffer!(EID), isInput: bool) {
            p: Port;
            p.valid = true;
            p.isInput = isInput;
            portId := addPort(p);
            b|:append(portId);
        }

        addPortToNode(&n, &n.inputs, true);
        addPortToNode(&n, &n.inputs, true);

        addPortToNode(&n, &n.outputs, false);
        addPortToNode(&n, &n.outputs, false);
        addPortToNode(&n, &n.outputs, false);
        addPortToNode(&n, &n.outputs, false);

        addNode(n);
    }

    context.state.nodeBeingDragged = -1;
    context.state.portBeingDragged = -1;

    context.state.dragging = false;
}

fn removeConnection(index: i64) {
    connection := context.state.connections.buf[index];

    from := findPort(connection.from);
    to := findPort(connection.to);

    from.connections -= 1;
    to.connections -= 1;

    &context.state.connections|buf.deleteByReordering(index);
}

fn keydown(messageData: *sdl.KeyboardEvent) {
    if messageData.keysym.scancode == sdl.Key.SPACE {
        io.println("space");
    }
    else if messageData.keysym.scancode == sdl.Key.LEFT {
        io.println("left");
    }
}

fn tmp_scale() {
    -- if context.modifierKeys.shift {
        -- diff := context.state.scale - 1.5;
        -- context.state.scale -= diff / 2;
    -- }
    -- else {
        -- diff := 1.0 - context.state.scale;
        -- context.state.scale += diff / 2;
    -- }

    cairo.cairo_save(context.cairo.layer.context);
    cairo.cairo_scale(context.cairo.layer.context, context.state.scale, context.state.scale);
}

fn findNode(id: EID) *Node {
    basic.assertMsg(id >= 0 and id < context.state.nodes.buf.count, "invalid node id");
    return &context.state.nodes.buf[id];
}

fn findPort(id: EID) *Port {
    basic.assertMsg(id >= 0 and id < context.state.ports.buf.count, "invalid port id");
    return &context.state.ports.buf[id];
}

fn magFactor(port: *Port) {
    mf: f64 = 1.0;

    dist := gui.distance(port.center, context.state.transformedMouse);
    if dist < 20 {
        dist /= 10;
        mf = math.min(5 - (dist * dist), 2.5);
    }

    return mf;
}

fn drawNode(node: *Node) {
    fontSize: f64 = 78;

    nodeColor: gui.Color = {cast(f64) 167.0/255.0, cast(f64) 98.0/255.0, cast(f64) 82.0/255.0};
    if node.active == true or context.state.canvasBeingDragged == true {
        nodeColor = {cast(f64) 98.0/255.0, cast(f64) 167.0/255.0, cast(f64) 82.0/255.0};
    }

    gui.drawRoundedRect(context.cairo.layer,
        node.rect,
        nodeColor.r, nodeColor.g, nodeColor.b,
        radius: PORT_RADIUS, lineWidth: 5);

    -- draw ports
    drawPorts(node, nodeColor, node.inputs.buf, node.rect.x + 15);
    drawPorts(node, nodeColor, node.outputs.buf, node.rect.x + node.rect.width - 15);

    -- text.drawBoundedText("0.5", bounds: {node.rect.x + 20, node.rect.y, node.rect.width/2 - 20, node.rect.height});
}

fn drawPorts(node: *Node, color: gui.Color, ports: []EID, x: f64) {
    portSpacing := node.rect.height / cast() ports.count;
    totalPortSpace := portSpacing * cast() (ports.count - 1);
    totalSpace := node.rect.height;
    yOffset: f64 = (totalSpace - totalPortSpace) / 2;

    for portId: ports {
        port := findPort(portId);

        port.center = {x, node.rect.y + yOffset};
        yOffset += portSpacing;

        mf := magFactor(port);

        gui.drawCircle(context.cairo.layer,
            port.center,
            PORT_RADIUS * mf,
            color.r, color.g, color.b,
            lineWidth: 1);
    }
}

fn drawConnection(connection: Connection) {
    p1 := findPort(connection.from).center;
    p2 := findPort(connection.to).center;

    gui.drawCurve(context.cairo.layer,
        p1: p1,
        p2: p2,
        cp1: cast() {
            x: gui.lerp(p1.x, p2.x, 0.3),
            y: p1.y,
        },
        cp2: cast() {
            x: gui.lerp(p1.x, p2.x, 0.7),
            y: p2.y,
        },
        color: {
            r: cast(f64) 250.0/255.0,
            g: cast(f64) 215.0/255.0,
            b: cast(f64) 0.0/255.0,
        },
        width: 4,
    );
}

fn draw(rect: gui.Rect) {
    -- background
    gui.drawRect(context.cairo.layer, rect, cast(f64) 67.0/255.0, cast(f64) 77.0/255.0, cast(f64) 82.0/255.0);

    tmp_scale();
    defer { cairo.cairo_restore(context.cairo.layer.context); }

    -- connections
    for connection: context.state.connections.buf {
        drawConnection(connection);
    }
    if context.state.portBeingDragged != -1 {
        port := findPort(context.state.portBeingDragged);

        p1 := port.center;
        p2 := context.state.transformedMouse;

        cp1: gui.Point!(f64) = {gui.lerp(p1.x, p2.x, 0.3), p1.y};
        cp2: gui.Point!(f64) = {gui.lerp(p1.x, p2.x, 0.7), p2.y};

        color: gui.Color = {
            r: cast(f64) 250.0/255.0,
            g: cast(f64) 215.0/255.0,
            b: cast(f64) 0.0/255.0,
        };

        gui.drawCurve(context.cairo.layer,
            p1: p1,
            p2: p2,
            cp1: cp1,
            cp2: cp2,
            color: color,
            width: 4,
        );
    }

    -- nodes
    for node: context.state.nodes.buf|iter.byRef {
        if node.valid == true {
            drawNode(node);
        }
    }
}
