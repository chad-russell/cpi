#import "gui/gui";
#import "gui/text";
#import "io";
#import "buffer": buf;
#import "sdl";
#import "cairo";
#import "math";
#import "iter";

PORT_RADIUS: f64 = 3;

type EID i64

#context state: struct {
    scale: f64,

    entities: buf.Buffer!(EID),
    nodes: buf.Buffer!(Node),
    ports: buf.Buffer!(Port),

    connections: buf.Buffer!(Connection),

    transformedMouse: gui.Point!(f64),

    mouseDownStart: gui.Point!(f64),
    mouseDown := false,

    canvasBeingDragged := false,
    dragging := false,

    nodeBeingDragged: EID = 0,
    portBeingDragged: EID = 0,
    tentativeConnection: EID = 0,
}

type Node struct {
    id: EID,

    rect: gui.Rect,
    active: bool,

    inputs: buf.Buffer!(EID),
    outputs: buf.Buffer!(EID),
}

type Port struct {
    id: EID,

    isInput: bool,
    center: gui.Point!(f64),
}

type Connection struct {
    from: EID,
    to: EID,
}

fn makeNodeId() EID {
    context.state.eid += 1;
    return cast() context.state.eid;
}

fn makePortId() EID {
    context.state.eid += 1;
    return cast() context.state.eid;
}

fn init() {
    basic.initContext();

    gui.init();

    text.init();

    context.state.scale = 1.0;

    while !context.quit {
        gui.tick();

        processMessages();
        draw(gui.windowRect());

        gui.commit();
    }

    return 0;
}

fn processMessages() {
    tmp_scale();
    defer { cairo.cairo_restore(context.cairo.layer.context); }

    if context.keyDownEvent != nil {
        keydown(context.keyDownEvent);
    }
    if context.mouseMotionEvent != nil {
        mouseMove(context.mouseMotionEvent);
    }
    if context.mouseButtonDownEvent != nil {
        mouseButtonDown(context.mouseButtonDownEvent);
    }
    if context.mouseButtonUpEvent != nil {
        mouseButtonUp(context.mouseButtonUpEvent);
    }
}

fn checkMouseDownInPort(port: *Port) {
    if gui.distance(port.center, context.state.transformedMouse) < magFactor(port) * PORT_RADIUS {
        alreadyInConnection := false;
        c: Connection;
        cIndex: i64;

        for connection, i: context.state.connections.buf {
            if connection.from == port.id or connection.to == port.id {
                alreadyInConnection = true;
                c = connection;
                cIndex = i;
            }
        }

        if alreadyInConnection == true {
            &context.state.connections|:buf.deleteByReordering(cIndex);

            if c.from == port.id {
                context.state.portBeingDragged = c.to;
            }
            else {
                context.state.portBeingDragged = c.from;
            }
        }
        else {
            context.state.nodeBeingDragged = 0;
            context.state.portBeingDragged = port.id;
        }
    }
}

fn mouseButtonDown(messageData: *sdl.MouseButtonEvent) {
    context.state.mouseDownStart = context.state.transformedMouse;
    context.state.mouseDown = true;
    context.state.dragging = false;

    context.state.nodeBeingDragged = 0;
    context.state.portBeingDragged = 0;

    mouseDownInPort := false;
    for port: context.state.ports.buf|iter.byRef {
        checkMouseDownInPort(port);
    }

    if mouseDownInPort == false {
        for node: context.state.nodes.buf {
            if node.rect|gui.contains(context.state.transformedMouse.x, context.state.transformedMouse.y) == true {
                context.state.nodeBeingDragged = node.id;
            }
        }
    }
}

fn mouseMove(messageData: *sdl.MouseMotionEvent) {
    context.state.transformedMouse = context.mouse;
    cairo.cairo_device_to_user(context.cairo.layer.context, &context.state.transformedMouse.x, &context.state.transformedMouse.y);

    dx := context.state.transformedMouse.x - context.state.mouseDownStart.x;
    dy := context.state.transformedMouse.y - context.state.mouseDownStart.y;

    if context.state.mouseDown {
        context.state.dragging = true;
        context.state.mouseDownStart = context.state.transformedMouse;
    }

    context.state.tentativeConnection = 0;
    if context.state.portBeingDragged != 0 {
        -- establish a connection?
        for port: context.state.ports.buf|iter.byRef {
            mf := magFactor(port);

            if port.id != context.state.portBeingDragged and gui.distance(context.state.transformedMouse, port.center) < PORT_RADIUS * mf {
                context.state.tentativeConnection = port.id;
            }
        }
    }
    else if context.state.nodeBeingDragged != 0 {
        nbd := findNode(context.state.nodeBeingDragged);

        nbd.active = true;
        nbd.rect.x += dx;
        nbd.rect.y += dy;
    }
    else if context.state.mouseDown {
        context.state.canvasBeingDragged = true;

        for node: context.state.nodes.buf|iter.byRef {
            node.rect.x += dx;
            node.rect.y += dy;
        }
    }
    else {
        for node: context.state.nodes.buf|iter.byRef {
            if node.rect|gui.contains(context.state.transformedMouse.x, context.state.transformedMouse.y) {
                node.active = true;
            }
            else {
                node.active = false;
            }
        }
    }
}

fn mouseButtonUp(messageData: *sdl.MouseButtonEvent) {
    context.state.mouseDown = false;
    context.state.canvasBeingDragged = false;

    if context.state.tentativeConnection != 0 {
        &context.state.connections|:append({
            from: context.state.portBeingDragged,
            to: context.state.tentativeConnection,
        });

        context.state.tentativeConnection = 0;
    }
    else if messageData.button == sdl.MouseButton.RIGHT {
        -- delete node

        node := findNode(context.state.nodeBeingDragged);
        if node != nil {
            -- delete any connections that involve a node's inputs or outputs
            for c: context.state.connections.buf {
                shouldDelete := false;

                for p: node.inputs.buf {
                    if p == c.to or p == c.from {
                        shouldDelete = true;
                    }
                }
                for p: node.outputs.buf {
                    if p == c.to or p == c.from {
                        shouldDelete = true;
                    }
                }

                if shouldDelete == true {
                    &context.state.connections|buf.deleteByReordering(cIndex);
                }
            }

            -- delete ports from the node
            for p: node.inputs.buf {
                pIndex := findPortIndex(p);
                &context.state.ports|buf.deleteByReordering(pIndex);
            }
            for p: node.outputs.buf {
                pIndex := findPortIndex(p);
                &context.state.ports|buf.deleteByReordering(pIndex);
            }

            -- delete the node
            nodeIndex := findNodeIndex(context.state.nodeBeingDragged);
            &context.state.nodes|buf.deleteByReordering(nodeIndex);
        }
    }
    else if context.state.dragging == false {
        -- make a new node
        n: Node;
        n.id = makeNodeId();
        n.rect = {context.state.transformedMouse.x, context.state.transformedMouse.y, 200, 100};
        n.active = true;

        fn addPort(n: *Node, b: *buf.Buffer!(EID)) {
            p: Port;
            p.id = makePortId();
            p.isInput = true;

            &context.state.ports|:append(p);
            b|:append(p.id);
        }

        addPort(&n, &n.inputs);
        addPort(&n, &n.inputs);

        addPort(&n, &n.outputs);
        addPort(&n, &n.outputs);
        addPort(&n, &n.outputs);
        addPort(&n, &n.outputs);

        &context.state.nodes|:append(n);
    }

    context.state.nodeBeingDragged = 0;
    context.state.portBeingDragged = 0;

    context.state.dragging = false;
}

fn findNodeIndex(id: EID) i64 {
    for node, nIndex: context.state.nodes.buf {
        if id == node.id {
            return nIndex;
        }
    }

    return -1;
}

fn findPortIndex(id: EID) i64 {
    for port, pIndex: context.state.ports.buf {
        if id == port.id {
            return pIndex;
        }
    }

    return -1;
}

fn keydown(messageData: *sdl.KeyboardEvent) {
    if messageData.keysym.scancode == sdl.Key.SPACE {
        io.println("space");
    }
    else if messageData.keysym.scancode == sdl.Key.LEFT {
        io.println("left");
    }
}

fn tmp_scale() {
    if context.modifierKeys.shift {
        diff := context.state.scale - 1.5;
        context.state.scale -= diff / 2;
    }
    else {
        diff := 1.0 - context.state.scale;
        context.state.scale += diff / 2;
    }

    cairo.cairo_save(context.cairo.layer.context);
    cairo.cairo_scale(context.cairo.layer.context, context.state.scale, context.state.scale);
}

fn findNode(id: EID) *Node {
    for n: context.state.nodes.buf|iter.byRef {
        if n.id == id { return n; }
    }
    return nil;
}

fn findPort(id: EID) *Port {
    for p: context.state.ports.buf|iter.byRef {
        if p.id == id { return p; }
    }
    return nil;
}

fn magFactor(port: *Port) {
    mf: f64 = 1.0;

    dist := gui.distance(port.center, context.state.transformedMouse);
    if dist < 20 {
        dist /= 10;
        mf = math.min(5 - (dist * dist), 2.5);
    }

    return mf;
}

fn drawNode(node: *Node) {
    fontSize: f64 = 78;

    nodeColor: gui.Color = {cast(f64) 167.0/255.0, cast(f64) 98.0/255.0, cast(f64) 82.0/255.0};
    if node.active == true or context.state.canvasBeingDragged == true {
        nodeColor = {cast(f64) 98.0/255.0, cast(f64) 167.0/255.0, cast(f64) 82.0/255.0};
    }

    gui.drawRoundedRect(context.cairo.layer,
        node.rect,
        nodeColor.r, nodeColor.g, nodeColor.b,
        radius: PORT_RADIUS, lineWidth: 5);

    -- draw ports
    drawPorts(node, nodeColor, node.inputs.buf, node.rect.x + 15);
    drawPorts(node, nodeColor, node.outputs.buf, node.rect.x + node.rect.width - 15);

    -- text.drawBoundedText("0.5", bounds: {node.rect.x + 20, node.rect.y, node.rect.width/2 - 20, node.rect.height});
}

fn drawPorts(node: *Node, color: gui.Color, ports: []EID, x: f64) {
    portSpacing := node.rect.height / cast() ports.count;
    totalPortSpace := portSpacing * cast() (ports.count - 1);
    totalSpace := node.rect.height;
    yOffset: f64 = (totalSpace - totalPortSpace) / 2;

    for portId: ports {
        port := findPort(portId);

        port.center = {x, node.rect.y + yOffset};
        yOffset += portSpacing;

        mf := magFactor(port);

        gui.drawCircle(context.cairo.layer,
            port.center,
            PORT_RADIUS * mf,
            color.r, color.g, color.b,
            lineWidth: 1);
    }
}

fn drawConnection(connection: Connection) {
    p1 := findPort(connection.from).center;
    p2 := findPort(connection.to).center;

    gui.drawCurve(context.cairo.layer,
        p1: p1,
        p2: p2,
        cp1: cast() {
            x: gui.lerp(p1.x, p2.x, 0.3),
            y: p1.y,
        },
        cp2: cast() {
            x: gui.lerp(p1.x, p2.x, 0.7),
            y: p2.y,
        },
        color: {
            r: cast() 250.0/255.0,
            g: cast() 215.0/255.0,
            b: cast() 0.0/255.0,
        },
        width: 4,
    );
}

fn draw(rect: gui.Rect) {
    -- background
    gui.drawRect(context.cairo.layer, rect, cast(f64) 67.0/255.0, cast(f64) 77.0/255.0, cast(f64) 82.0/255.0);

    tmp_scale();
    defer { cairo.cairo_restore(context.cairo.layer.context); }

    -- connections
    for connection: context.state.connections.buf {
        drawConnection(connection);
    }
    if context.state.portBeingDragged != 0 {
        port := findPort(context.state.portBeingDragged);

        p1 := port.center;
        p2 := context.state.transformedMouse;

        cp1: gui.Point!(f64) = {gui.lerp(p1.x, p2.x, 0.3), p1.y};
        cp2: gui.Point!(f64) = {gui.lerp(p1.x, p2.x, 0.7), p2.y};

        color: gui.Color = {
            r: cast(f64) 250.0/255.0,
            g: cast(f64) 215.0/255.0,
            b: cast(f64) 0.0/255.0,
        };

        gui.drawCurve(context.cairo.layer,
            p1: p1,
            p2: p2,
            cp1: cp1,
            cp2: cp2,
            color: color,
            width: 4,
        );
    }

    -- nodes
    for node: context.state.nodes.buf|iter.byRef {
        drawNode(node);
    }
}
