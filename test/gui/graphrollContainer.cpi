#import "gui/gui";
#import "gui/graphroll";
#import "sdl";
#import "buffer": buf;
#import "io";

type GraphRollContainerFormData struct {
    rect: gui.Rect!(f64),
    bounds: gui.Rect!(f64),
    metaRect: gui.Rect!(f64),
    gr: graphroll.GraphRollFormData
}

fn draw(rect: gui.Rect!(f64), bounds: gui.Rect!(f64), index: i64, metaMargin: f64, scrollOffsetY: f64) {
    state := &context.state.playArea.graphRolls.buf[index];
    state.rect = rect;
    state.bounds = bounds;

    rc := rect;
    rc.y += scrollOffsetY;

    -- delete handle
    state.metaRect = {rc.x, rc.y, metaMargin, rc.height};
    gui.drawRect(context.cairo.layer, gui.clip(state.metaRect, bounds), 0.9, 0.6, 0.6);

    rc.x += metaMargin;
    rc.width -= metaMargin;

    grBounds := bounds;
    grBounds.x = metaMargin;
    grBounds.width -= metaMargin;

    graphroll.draw(rc, grBounds, index);
}

fn mouseButtonDown(messageData: *sdl.MouseButtonEvent, index: i64) {
    state := &context.state.playArea.graphRolls.buf[index];

    -- delete handle
    if state.metaRect|gui.containsMouse {
        &context.state.playArea.graphRolls|buf.deleteInPlace(index);
    }
    else {
        graphroll.mouseButtonDown(messageData, index);
    }
}
