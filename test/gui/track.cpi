#import "gui/gui";
#import "gui/graphroll";
#import "gui/scroller";
#import "gui/playarea";
#import "io";
#import "buffer": buf;
#import "sdl";
#import "math";
#import "iter";

type Clip struct {
    rect: gui.Rect!(f64),
    editButton: gui.Rect!(f64),
    selected: bool,
    graphRoll: graphroll.GraphRollFormData
}

type TrackState struct {
    rect: gui.Rect!(f64),
    bounds: gui.Rect!(f64),

    clips: buf.Buffer!(Clip),

    selecting: bool,
    selectStartX: f64,
    selectStartY: f64,

    draggingClips: bool,
    dragStartX: f64,
    dragStartY: f64,

    mouseInResizeArea: bool,
    resizingClips: bool,
    resizeStartX: f64,

    xResolution: f64
}

fn selectArea(state: TrackState) gui.Rect!(f64) {
    startX := state.selectStartX;
    startY := state.selectStartY;
    endX := context.mouse.x;
    endY := context.mouse.y;

    if startX > endX {
        startX = context.mouse.x;
        endX = state.selectStartX;
    }

    if startY > endY {
        startY = context.mouse.y;
        endY = state.selectStartY;
    }

    return {
        startX,
        startY,
        endX - startX,
        endY - startY
    };
}

fn yResolution(state: TrackState) f64 {
    return state.rect.height;
}

fn screenPixels(state: TrackState, x: f64) {
    hs := &context.state.playArea.horizontalScroller;
    scaleX := hs.rect.width / (hs.end - hs.begin);

    scrollBeginPercent := hs.begin / hs.rect.width;
    scrollEndPercent := hs.end / hs.rect.width;

    startWindow := state.rect.width * scrollBeginPercent;
    endWindow := state.rect.width * scrollEndPercent;
    windowPixels := endWindow - startWindow;

    pixels := x - startWindow;
    return state.rect.x + pixels * scaleX;
}

fn effectiveRect(clip: Clip, state: TrackState) gui.Rect!(f64) {
    offsetX: f64 = 0;
    offsetY: f64 = 0;

    localX := context.mouse.x - state.rect.x;
    localY := context.mouse.y - state.rect.y;

    resizeX: f64 = 0;

    yr := yResolution(state);
    clipY := math.floor(localY / yr);

    if clip.selected == true and state.draggingClips == true {
        offsetX = context.mouse.x - state.dragStartX;
        offsetY = clipY - state.dragStartY;
    }

    if clip.selected == true and state.resizingClips == true {
        resizeX = context.mouse.x - state.resizeStartX;
    }

    sp := screenPixels(state, clip.rect.x);

    hs := &context.state.playArea.horizontalScroller;
    scaleX := hs.rect.width / (hs.end - hs.begin);

    er: gui.Rect!(f64) = {
        sp + offsetX,
        state.rect.y + (clip.rect.y + offsetY) * yr,
        (clip.rect.width) * state.xResolution * scaleX + resizeX,
        clip.rect.height * yr
    };

    return gui.clip(er, state.bounds);
}

fn mouseButtonDown(messageData: *sdl.MouseButtonEvent, index: i64) {
    state := &context.state.playArea.tracks.buf[index].tr;

    localX := context.mouse.x - state.rect.x;
    localY := context.mouse.y - state.rect.y;

    if messageData.button == sdl.MouseButton.LEFT {
        didClickClip := false;
        clipClicked: *Clip = nil;

        -- possibly select existing clips
        for clip: state.clips.buf|iter.byRef {
            if clip.editButton|gui.containsMouse {
                context.state.playArea.screenType = playarea.ScreenType.Track;
                context.state.playArea.screenData = clip;

                return;
            }
            else if effectiveRect(^clip, ^state)|gui.containsMouse {
                didClickClip = true;
                clipClicked = clip;
            }
        }

        if didClickClip == true {
            if context.modifierKeys.ctrl == false and clipClicked.selected == false {
                -- clear all selected clips
                for clip: state.clips.buf|iter.byRef {
                    clip.selected = false;
                }
            }

            clipClicked.selected = !context.modifierKeys.shift;
            if clipClicked.selected == true {
                if state.mouseInResizeArea == true {
                    state.resizingClips = true;
                    state.resizeStartX = context.mouse.x;
                }
                else {
                    state.draggingClips = true;
                    state.dragStartX = context.mouse.x;

                    yr := yResolution(^state);
                    clipY := math.floor(localY / yr);
                    state.dragStartY = clipY;
                }
            }

            return;
        }
        else if context.modifierKeys.ctrl == true {
            -- box select
            state.selecting = true;
            state.selectStartX = context.mouse.x;
            state.selectStartY = context.mouse.y;

            return;
        }

        if context.modifierKeys.shift {
            for clip: state.clips.buf|iter.byRef {
                clip.selected = false;
            }
            return;
        }

        for clip: state.clips.buf|iter.byRef {
            clip.selected = false;
        }

        -- add a new one
        hs := &context.state.playArea.horizontalScroller;
        scaleX := hs.rect.width / (hs.end - hs.begin);

        yr := yResolution(^state);
        clipY := math.floor(localY / yr);

        scrollBeginPercent := hs.begin / hs.rect.width;
        scrollEndPercent := hs.end / hs.rect.width;

        startWindow := state.rect.width * scrollBeginPercent;
        endWindow := state.rect.width * scrollEndPercent;
        windowPixels := endWindow - startWindow;

        clickedPercent := localX / state.rect.width;
        clickedInWindow := windowPixels * clickedPercent;
        clickedLocation := startWindow + clickedInWindow;

        clipRect: gui.Rect!(f64) = {clickedLocation, clipY, 16, 1};

        clip: Clip;
        clip.rect = clipRect;
        clip.selected = false;

        &state.clips|:append(clip);
    }
    else if messageData.button == sdl.MouseButton.RIGHT {
        toDelete := false;
        i := 0;
        for clip: state.clips.buf|iter.byRef {
            if effectiveRect(^clip, ^state)|gui.contains(context.mouse.x, context.mouse.y) {
                if context.modifierKeys.shift == false {
                    clip.selected = true;
                    toDelete = true;
                }
            }

            i += 1;
        }

        if toDelete == true {
            writeIndex := 0;
            readIndex := 0;
            while readIndex < state.clips.buf.count {
                if state.clips.buf[readIndex].selected == false {
                    state.clips.buf[writeIndex] = state.clips.buf[readIndex];
                    writeIndex += 1;
                }

                readIndex += 1;
            }

            state.clips.buf.count = writeIndex;
        }
    }
}

fn mouseButtonUp(messageData: *sdl.MouseButtonEvent, index: i64) {
    state := &context.state.playArea.tracks.buf[index].tr;

    hs := &context.state.playArea.horizontalScroller;
    scaleX := (hs.end - hs.begin) / hs.rect.width;

    localX := context.mouse.x - state.rect.x;
    localY := context.mouse.y - state.rect.y;

    if state.draggingClips == true {
        yr := yResolution(^state);
        dragStopY := math.floor(localY / yr);

        for clip: state.clips.buf|iter.byRef {
            if clip.selected == true {
                clip.rect.x += (context.mouse.x - state.dragStartX) * scaleX;
                clip.rect.y += dragStopY - state.dragStartY;
            }
        }

        state.draggingClips = false;
    }

    if state.resizingClips == true {
        for clip: state.clips.buf|iter.byRef {
            if clip.selected == true {
                clip.rect.width += (context.mouse.x - state.resizeStartX) * scaleX / state.xResolution;
            }
        }

        state.resizingClips = false;
    }

    state.selecting = false;
}

fn mouseMove(messageData: *sdl.MouseMotionEvent, index: i64) {
    state := &context.state.playArea.tracks.buf[index].tr;

    if state.resizingClips == true {
        return;
    }

    localX := context.mouse.x - state.rect.x;
    localY := context.mouse.y - state.rect.y;

    if state.selecting == false {
        for clip: state.clips.buf {
            er := effectiveRect(clip, ^state);

            endRect: gui.Rect!(f64) = {
                er.x + er.width - 4,
                er.y,
                4,
                er.height
            };

            if endRect|gui.contains(context.mouse.x, context.mouse.y) {
                sdl.SDL_SetCursor(context.arrowCursorWE);
                state.mouseInResizeArea = true;
                return;
            }
        }

        sdl.SDL_SetCursor(context.arrowCursor);
        state.mouseInResizeArea = false;

        return;
    }

    if context.modifierKeys.ctrl == false {
        state.selecting = false;
        return;
    }

    if state.selecting == true {
        -- convert selectArea to local coordinates
        sa := selectArea(^state);

        for clip: state.clips.buf|iter.byRef {
            if effectiveRect(^clip, ^state)|gui.intersects(sa) {
                clip.selected = !context.modifierKeys.shift;
            }
        }
    }
}

fn quantize(origY: f64, size: f64) {
    return math.floor(origY / size) * size;
}

fn draw(rect: gui.Rect!(f64), bounds: gui.Rect!(f64), state: *TrackState) {
    state.rect = rect;
    state.bounds = bounds;

    -- background
    gui.drawRect(context.cairo.layer, gui.clip(rect, bounds), cast(f64) 67.0/255.0, cast(f64) 84.0/255.0, cast(f64) 94.0/255.0);

    -- outline
    gui.drawOutline(context.cairo.layer, gui.clip(rect, bounds), 0.2, 0.2, 0.2, lineWidth: 1.5);

    -- how many pixels per beat?
    microsecondsPerMinute: u64 = 60000000;
    compositionLengthInMinutes := cast(f64) context.state.playArea.compositionLengthInMicroseconds / cast(f64) microsecondsPerMinute;
    totalBeats := compositionLengthInMinutes * cast() context.state.playArea.beatsPerMinute;
    state.xResolution = state.rect.width / cast() totalBeats;

    -- vertical lines
    vlX: f64 = 0;
    light := true;
    lastX := vlX;

    blockWidth := state.xResolution * cast() context.state.beatsPerMeasure;

    while vlX < rect.x + rect.width {
        if light == true {
            pixelsStart := screenPixels(^state, vlX);
            pixelsEnd := screenPixels(^state, vlX + blockWidth);
            blockRect: gui.Rect!(f64) = {pixelsStart, rect.y, pixelsEnd - pixelsStart, rect.height};

            gui.drawRect(context.cairo.layer, gui.clip(blockRect, bounds), cast(f64) 52.0/255.0, cast(f64) 68.0/255.0, cast(f64) 78.0/255.0);
        }

        vlX += blockWidth;
        light = !light;
    }

    vlX = 0;
    vlN := 0;
    while vlX < rect.x + rect.width {
        pixelsX := screenPixels(^state, vlX);
        lineRect: gui.Rect!(f64) = gui.clip({pixelsX, rect.y, 0, rect.height}, bounds);

        if pixelsX > bounds.x and pixelsX < bounds.x + bounds.width {
            width: f64 = 1;
            if vlN mod cast() context.state.beatsPerMeasure == 0 {
                width = 2;
            }

            gui.drawLine(context.cairo.layer, lineRect, 0.2, 0.2, 0.2, width: width);
        }

        vlX += state.xResolution;
        vlN += 1;
    }

    yr := yResolution(^state);

    y := rect.y + yr;
    while y < rect.y + rect.height {
        guideLineRect: gui.Rect!(f64) = {rect.x, y, rect.width, 0};
        gui.drawLine(context.cairo.layer, gui.clip(guideLineRect, bounds), 0.2, 0.2, 0.2, width: 0.5);
        y += yr;
    }

    -- clips
    for clip: state.clips.buf|iter.byRef {
        drawClip(clip, state);
    }

    -- select area
    if state.selecting {
        gui.drawRect(context.cairo.layer, selectArea(^state), 0.9, 0.9, 0.9, 0.2);
    }
}

fn drawClip(clip: *Clip, state: *TrackState) {
    er := effectiveRect(^clip, ^state);

    if clip.selected {
        gui.drawRect(context.cairo.layer, er, cast(f64) 186.0/255.0, cast(f64) 194.0/255.0, cast(f64) 239.0/255.0);
    }
    else {
        gui.drawRect(context.cairo.layer, er, cast(f64) 117.0/255.0, cast(f64) 130.0/255.0, cast(f64) 144.0/255.0);
    }

    -- edit button
    clip.editButton = {er.x + er.width - 12, er.y + er.height - 12, 10, 10};
    gui.drawRect(context.cairo.layer, clip.editButton, cast(f64) 144.0/255.0, cast(f64) 130.0/255.0, cast(f64) 117.0/255.0);
}
