#import "sdl";
#import "buffer": buf;
#import "io";
#import "cairo";
#import "mem";
#import "string";
#import "iter";
#import "time";

WIDTH   : i32 = 1000;
HEIGHT  : i32 = 600;

DRAW        := "draw";
MOUSEDOWN   := "mousedown";
MOUSEMOVE   := "mousemove";
MOUSEUP     := "mouseup";
MOUSESCROLL := "mousescroll";
KEYDOWN     := "keydown";

type Color struct {
    r: f64,
    g: f64,
    b: f64,
    a: f64 = 1.0
}

#context mouse: struct {
    x: f64,
    y: f64
}

type MouseMessageData struct {
    x: f64,
    y: f64
}

type MouseScrollMessageData struct {
    x: f64,
    y: f64,
    flipped := false
}

type KeyboardMessageData struct {
    scancode: sdl.Key
}

type Rect(T := typeof(x)) struct {
    x: T,
    y: T,
    width: T,
    height: T
}

type Point(T := typeof(x)) struct {
    x: T,
    y: T
}

fn contains(T := typeof(r.x))(r: !R/Rect, x: T, y: T) {
    er := r;

    return er.x <= x
       and er.x + er.width >= x
       and er.y <= y
       and er.y + er.height >= y;
}

fn containsMouse(T := typeof(r.x))(r: !R/Rect) {
    return contains(r, context.mouse.x, context.mouse.y);
}

fn intersects(r1: !R/Rect, r2: R) {
    -- If one rectangle is on left side of other
    if r1.x > r2.x + r2.width or r2.x > r1.x + r1.width {
        return false;
    }

    -- If one rectangle is above other
    if r1.y > r2.y + r2.height or r2.y > r1.y + r1.height {
        return false;
    }

    return true;
}

type Message struct {
    name: []i8,
    data: *none
}

type ReceiverHandler fn(formId: i64, formData: *none, messageData: *none) none

type Receiver struct {
    name: []i8,
    handle: ReceiverHandler
}

type Layer struct {
    surface: *cairo.Surface,
    context: *cairo.Context
}

fn makeLayer(rect: Rect!(f64)) {
    layerSurface := cairo.cairo_image_surface_create(cairo.FORMAT_ARGB32,
        cast() rect.width,
        cast() rect.height);

    layerContext := cairo.cairo_create(layerSurface);

    cairo.cairo_surface_set_device_scale(layerSurface, context.sdl.xScale, context.sdl.yScale);

    return cast(Layer) {layerSurface, layerContext};
}

#context sdl: struct {
    window: *sdl.Window,
    surface: *sdl.Surface,
    renderer: *sdl.Renderer,

    texture: *sdl.Texture,
    pixels: *none,
    pitch: i32,

    windowWidth: i32,
    windowHeight: i32,

    rendererWidth: i32,
    rendererHeight: i32,

    xScale: f64,
    yScale: f64,
}

fn windowRect() Rect!(f64) {
    return {0, 0, cast(f64) context.sdl.windowWidth, cast(f64) context.sdl.windowHeight};
}

#context cairo: struct {
    font: *cairo.FontFace,
    emojiFont: *cairo.FontFace,
    layer: Layer
}

fn initSdl() {
    err := sdl.SDL_Init(sdl.INIT_VIDEO);
    if err != 0 {
        io.println("failed to init SDL");
        panic();
    }

    window := sdl.SDL_CreateWindow("editor"|string.cstr,
        sdl.WINDOWPOS_UNDEFINED, sdl.WINDOWPOS_UNDEFINED,
        WIDTH, HEIGHT,
        8196);
    if window == nil {
        io.println("failed to create window");
        panic();
    }

    context.sdl.window = window;

    sdlRenderFlags: i32 = 6;
    -- sdlRenderFlags: i32 = 0;
    context.sdl.renderer = sdl.SDL_CreateRenderer(context.sdl.window, -1, sdlRenderFlags);

    -- Compute screen resolution
    -- For instance, on a retina screen, renderer size is twice as window size
    sdl.SDL_GetWindowSize(context.sdl.window, &context.sdl.windowWidth, &context.sdl.windowHeight);

    sdl.SDL_GetRendererOutputSize(context.sdl.renderer, &context.sdl.rendererWidth, &context.sdl.rendererHeight);

    -- Create a SDL surface for Cairo to render onto
    context.sdl.surface = sdl.SDL_CreateRGBSurface(
            0,
            context.sdl.rendererWidth,
            context.sdl.rendererHeight,
            32,
            0x00ff0000,
            0x0000ff00,
            0x000000ff,
            0xff000000
    );

    context.sdl.texture = sdl.SDL_CreateTexture(context.sdl.renderer,
        sdl.PIXEL_FORMAT_ARGB8888,
        sdl.TextureAccess.STREAMING,
        context.sdl.rendererWidth, context.sdl.rendererHeight);

    sdl.SDL_LockTexture(context.sdl.texture, nil, &context.sdl.pixels, &context.sdl.pitch);

    context.sdl.xScale = cast(f64) context.sdl.rendererWidth / cast(f64) context.sdl.windowWidth;
    context.sdl.yScale = cast(f64) context.sdl.rendererHeight / cast(f64) context.sdl.windowHeight;
}

fn initCairo() {
    -- Get Cairo surface form SDL2 surface
    context.cairo.layer.surface = cairo.cairo_image_surface_create_for_data(
                cast() context.sdl.pixels,
                cairo.FORMAT_ARGB32,
                context.sdl.surface.w,
                context.sdl.surface.h,
                context.sdl.surface.pitch);

    context.cairo.layer.context = cairo.cairo_create(context.cairo.layer.surface);

    cairo.cairo_surface_set_device_scale(context.cairo.layer.surface, context.sdl.xScale, context.sdl.yScale);
}

#context arrowCursor: *sdl.Cursor
#context arrowCursorWE: *sdl.Cursor
#context arrowCursorNS: *sdl.Cursor
#context arrowCursorHand: *sdl.Cursor

fn init() {
    initSdl();
    initCairo();

    context.quit = false;

    context.frame = 0;

    #import "time";
    context.start = time.clock();
    context.lastFrameTime := context.start;

    context.arrowCursor = sdl.SDL_CreateSystemCursor(sdl.CursorType.ARROW);
    context.arrowCursorWE = sdl.SDL_CreateSystemCursor(sdl.CursorType.SIZEWE);
    context.arrowCursorNS = sdl.SDL_CreateSystemCursor(sdl.CursorType.SIZENS);
    context.arrowCursorHand = sdl.SDL_CreateSystemCursor(sdl.CursorType.HAND);
}

fn drawRect(layer: Layer, rect: Rect!(f64), r: f64, g: f64, b: f64, a: f64 = 1) {
    cairo.cairo_save(layer.context);
    defer { cairo.cairo_restore(layer.context); }

    cairo.cairo_set_source_rgba(layer.context, r, g, b, a);
    cairo.cairo_rectangle(layer.context, rect.x, rect.y, rect.width, rect.height);
    cairo.cairo_fill(layer.context);
}

fn drawOutline(layer: Layer, rect: Rect!(f64), r: f64, g: f64, b: f64, a: f64 = 1, lineWidth: f64 = 1) {
    cairo.cairo_save(layer.context);
    defer { cairo.cairo_restore(layer.context); }

    cairo.cairo_set_source_rgba(layer.context, r, g, b, a);

    cairo.cairo_set_line_width(layer.context, lineWidth);

    cairo.cairo_move_to(layer.context, rect.x, rect.y);
    cairo.cairo_line_to(layer.context, rect.x + rect.width, rect.y);
    cairo.cairo_line_to(layer.context, rect.x + rect.width, rect.y + rect.height);
    cairo.cairo_line_to(layer.context, rect.x, rect.y + rect.height);

    cairo.cairo_stroke(layer.context);
}

fn drawLine(layer: Layer, startX: f64, startY: f64, endX: f64, endY: f64, r: f64, g: f64, b: f64, a: f64 = 1, lineWidth: f64 = 1) {
    cairo.cairo_save(layer.context);
    defer { cairo.cairo_restore(layer.context); }

    cairo.cairo_set_source_rgba(layer.context, r, g, b, a);

    cairo.cairo_set_line_width(layer.context, lineWidth);

    cairo.cairo_move_to(layer.context, startX, startY);
    cairo.cairo_line_to(layer.context, endX, endY);

    cairo.cairo_stroke(layer.context);
}

fn commit() {
    -- Render SDL2 surface onto SDL2 renderer
    sdl.SDL_UpdateTexture(context.sdl.texture, nil, context.sdl.pixels, context.sdl.pitch);
    sdl.SDL_RenderCopy(context.sdl.renderer, context.sdl.texture, nil, nil);
    sdl.SDL_RenderPresent(context.sdl.renderer);
}

fn shutdown() {
    cairo.cairo_surface_destroy(context.cairo.layer.surface);
    cairo.cairo_destroy(context.cairo.layer.context);

    sdl.SDL_FreeSurface(context.sdl.surface);
    sdl.SDL_Quit();
}

fn clearRect(layer: Layer, rect: Rect!(f64)) {
    cairo.cairo_save(layer.context);
    defer { cairo.cairo_restore(layer.context); }

    cairo.cairo_set_source_rgba(layer.context, 0, 0, 0, 0);
    cairo.cairo_set_operator(layer.context, cairo.Operator.SOURCE);
    if layer.context == context.cairo.layer.context {
        cairo.cairo_rectangle(layer.context, rect.x, rect.y, rect.width, rect.height);
    }
    else {
        cairo.cairo_rectangle(layer.context, 0, 0, rect.width, rect.height);
    }
    cairo.cairo_fill(layer.context);
}

#context quit: bool

#context mouseMotionEvent: *sdl.MouseMotionEvent
#context mouseWheelEvent: *sdl.MouseWheelEvent
#context mouseButtonDownEvent: *sdl.MouseButtonEvent
#context mouseButtonUpEvent: *sdl.MouseButtonEvent
#context keyDownEvent: *sdl.KeyboardEvent
#context keyUpEvent: *sdl.KeyboardEvent
#context modifierKeys: struct {
    shift: bool,
    ctrl: bool
}

fn processEvents() {
    event: sdl.Event;

    while sdl.SDL_PollEvent(&event) != 0 {
        if event._type == sdl.QUIT {
            shutdown();
            context.quit = true;
            io.printFln("% frames/sec", {cast(f64) context.frame / (cast(f64) context.elapsed / cast(f64) time.CLOCKS_PER_SEC)});
            return;
        }
        else if event._type == sdl.MOUSEMOTION {
            context.mouseMotionEvent = cast() mem.tmpHeap(event);

            x: i32;
            y: i32;
            sdl.SDL_GetMouseState(&x, &y);

            context.mouse.x = cast() x;
            context.mouse.y = cast() y;
        }
        else if event._type == sdl.MOUSEWHEEL {
            context.mouseWheelEvent = cast() mem.tmpHeap(event);
        }
        else if event._type == sdl.MOUSEBUTTONDOWN {
            context.mouseButtonDownEvent = cast() mem.tmpHeap(event);
        }
        else if event._type == sdl.MOUSEBUTTONUP {
            context.mouseButtonUpEvent = cast() mem.tmpHeap(event);
        }
        else if event._type == sdl.KEYDOWN {
            context.keyDownEvent = cast() mem.tmpHeap(event);

            if context.keyDownEvent.keysym.scancode == sdl.Key.CTRL {
                context.modifierKeys.ctrl = true;
            }
            if context.keyDownEvent.keysym.scancode == sdl.Key.SHIFT {
                context.modifierKeys.shift = true;
            }
        }
        else if event._type == sdl.KEYUP {
            context.keyUpEvent = cast() mem.tmpHeap(event);

            if context.keyUpEvent.keysym.scancode == sdl.Key.CTRL {
                context.modifierKeys.ctrl = false;
            }
            if context.keyUpEvent.keysym.scancode == sdl.Key.SHIFT {
                context.modifierKeys.shift = false;
            }
        }
    }
}

#context frame: u64
#context start: u64
#context lastFrameTime: u64
#context dt: u64
#context elapsed: u64

fn tick() {
    context.frame += 1;

    cur := time.clock();
    context.dt = cur - context.lastFrameTime;
    context.elapsed = cur - context.start;
    context.lastFrameTime = cur;

    basic.resetTmp();

    context.mouseMotionEvent = nil;
    context.mouseWheelEvent = nil;
    context.mouseButtonDownEvent = nil;
    context.mouseButtonUpEvent = nil;
    context.keyDownEvent = nil;
    context.keyUpEvent = nil;

    processEvents();

    -- io.println(context.frame);
    -- io.println("-------");
}
