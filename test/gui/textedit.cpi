#import "gui/gui";
#import "gui/slider";
#import "gui/scroll";
#import "se";
#import "sdl";
#import "buffer": buf;
#import "iter";
#import "math";
#import "cairo";
#import "harfbuzz": hb;
#import "freetype": ft;
#import "string";
#import "io";

TEXT_UPDATE := "text_update";

FONT_SIZE : i32 = 20;

sliderBackground: gui.Color = {0.4235, 0.4275, 0.4117};
sliderForeground: gui.Color = {0.8686, 0.7686, 0.7647};

#context cursor: *gui.Form

fn init() {
    context.tc.eb = se.editor_buffer_create(80);

    loadFonts();

    rect: gui.Rect!(f64) = {0, 0, 1, 0.075};
    makeGlobalUndoSlider(rect);

    rect = {0, 0.075, 1, 0.075};
    makeUndoSlider(rect);

    formRect: gui.Rect!(f64) = {
        x:      0,
        y:      0.15,
        width:  1.0,
        height: 0.85
    };

    textEditorId := make(formRect);
    textEditor := &context.forms.buf[textEditorId];

    cursorId := makeCursor(textEditor.data, textEditorId);
    cursor := &context.forms.buf[cursorId];
    context.cursor = cursor;

    scrollData := scroll.takeover(textEditor.rect, textEditorId);

    (cast(*CursorFormData) cursor.data).parentRect = &scrollData.effectiveRect;

    return textEditorId;
}

fn makeUndoSlider(rect: gui.Rect!(f64)) {
    sl := slider.create(rect, 50, sliderBackground, sliderForeground);

    sl|gui.addReceiver(
        TEXT_UPDATE,
        fn(formId: i64, formData: *slider.SliderFormData, messageData: *none) {
            -- set the max and the current
            formData.max = context.tc.eb.undo.length;
            formData.current = ^context.tc.eb.undoIdx;
            formId|gui.setFormNeedsDraw;
        }
    );

    sl|gui.addReceiver(
        slider.VALUE_UPDATE,
        fn(formId: i64, formData: *slider.SliderFormData, messageData: *gui.MouseMessageData) {
            gui.broadcast(TEXT_UPDATE);
            se.editor_buffer_undo(context.tc.eb, formData.current);
        }
    );
}

fn makeGlobalUndoSlider(rect: gui.Rect!(f64)) {
    sl := slider.create(rect, 50, sliderBackground, sliderForeground);

    sl|gui.addReceiver(
        TEXT_UPDATE,
        fn(formId: i64, formData: *slider.SliderFormData, messageData: *none) {
            -- set the max and the current
            formData.max = context.tc.eb.globalUndo.length;
            formData.current = ^context.tc.eb.globalUndoIdx;
            formId|gui.setFormNeedsDraw;
        }
    );

    sl|gui.addReceiver(
        slider.VALUE_UPDATE,
        fn(formId: i64, formData: *slider.SliderFormData, messageData: *gui.MouseMessageData) {
            gui.broadcast(TEXT_UPDATE);
            se.editor_buffer_global_undo(context.tc.eb, formData.current);
        }
    );
}

type CachedGlyph struct {
    codepoint: i32,
    extents: cairo.GlyphExtents,
    pattern: *cairo.Pattern
}

type CachedLine struct {
    low: f64,
    high: f64,
    glyphs: *buf.Buffer!(gui.Rect!(f64))
}

#context tc: struct {
    eb: *se.EditorBuffer,
}

#context hb: struct {
    font: *hb.Font,
    emojiFont: *hb.Font,
    buffer: *hb.Buffer = nil,
}

fn cacheGlyph(formData: *TextEditFormData, codepoint: i32, emoji: bool) {
    cairoGlyph := cairo.cairo_glyph_allocate(1);
    defer { cairo.cairo_glyph_free(cairoGlyph); }

    cairoGlyph.index = cast() codepoint;
    cairoGlyph.x = 0;
    cairoGlyph.y = 0;

    cached: CachedGlyph;
    cached.codepoint = codepoint;

    glyphSurface := cairo.cairo_image_surface_create(
            cairo.FORMAT_RGB24,
            cast() 500,
            cast() 500);
    cached.pattern = cairo.cairo_pattern_create_for_surface(glyphSurface);

    -- Scale cairo to use screen resolution
    cairo.cairo_surface_set_device_scale(glyphSurface, context.sdl.xScale, context.sdl.yScale);

    -- Get Cairo context from Cairo surface
    glyphContext := cairo.cairo_create(glyphSurface);

    if emoji {
        cairo.cairo_set_font_face(glyphContext, context.cairo.emojiFont);
    }
    else {
        cairo.cairo_set_font_face(glyphContext, context.cairo.font);
    }
    cairo.cairo_set_font_size(glyphContext, cast() FONT_SIZE);

    cairo.cairo_glyph_extents(glyphContext, cairoGlyph, 1, &cached.extents);

    -- clear the background
    cairo.cairo_set_source_rgb(glyphContext, 0.1739, 0.1867, 0.1433);
    cairo.cairo_rectangle(glyphContext,
        0, 0,
        cast() 40, cast() 40);
    cairo.cairo_fill(glyphContext);

    cairo.cairo_set_source_rgb(glyphContext, 0.965, 0.965, 0.941);
    cairo.cairo_translate(glyphContext, 0, -cached.extents.yBearing);
    cairo.cairo_show_glyphs(glyphContext, cairoGlyph, 1);

    &formData.glyphCache|:append(cached);
    return cached;
}

fn findGlyph(formData: *TextEditFormData, codepoint: i32, emoji: bool) CachedGlyph {
    for g: formData.glyphCache.buf {
        if g.codepoint == codepoint {
            return g;
        }
    }

    return cacheGlyph(formData, codepoint, emoji);
}

fn bytesInCodepointUtf8(firstByte: u8) {
    if (firstByte >= 0 and firstByte <= 191) {
        return 1;
    }

    if (firstByte >= 245) {
        return 1;
    }

    if (firstByte >= 192 and firstByte <= 223) {
        return 2;
    }

    if (firstByte >= 224 and firstByte <= 239) {
        return 3;
    }

    if (firstByte >= 240 and firstByte <= 244) {
        return 4;
    }

    panic();
    return 0;
}

fn isEmoji(codepoint: u64) {
    io.printFln("% is emoji?", {codepoint});

    -- Emoticons
    if codepoint >= 0x1F600 and codepoint <= 0x1F64F {
        return true;
    }

    -- Misc Symbols and Pictographs
    if codepoint >= 0x1F300 and codepoint <= 0x1F5FF {
        return true;
    }

    -- Transport and Map
    if codepoint >= 0x1F680 and codepoint <= 0x1F6FF {
        return true;
    }

    -- Regional country flags
    if codepoint >= 0x1F1E6 and codepoint <= 0x1F1FF {
        return true;
    }

    -- Misc symbols
    if codepoint >= 0x2600 and codepoint <= 0x26FF {
        return true;
    }

            -- 0x2700...0x27BF,   // Dingbats
            -- 0xFE00...0xFE0F,   // Variation Selectors
            -- 0x1F900...0x1F9FF,  // Supplemental Symbols and Pictographs
            -- 127000...127600, // Various asian characters
            -- 65024...65039, // Variation selector
            -- 9100...9300, // Misc items
            -- 8400...8447: // Combining Diacritical Marks for Symbols

    return false;
}

fn stateFor(text: *u8) struct{isEmoji: bool, byteLength: i32} {
    bytes := bytesInCodepointUtf8(^text);

    if bytes == 1 {
        return {false, 1};
    }
    else if bytes == 2 {
        return {isEmoji(cast(u64) ^cast(*u16) text), 2};
    }
    else if bytes == 3 {
        u: u64;
        pu := cast(*i8) &u;

        lastByte := cast(*u8) (pu + 3);
        middleTwoBytes := cast(*i16) (pu + 1);

        ^lastByte = ^(text + 2);
        ^middleTwoBytes = ^cast(*i16) text;

        return {isEmoji(u), 3};
    }
    else if bytes == 4 {
        return {isEmoji(cast(u64) ^cast(*u32) text), 4};
    }

    panic();
    return {false, -1};
}

fn runInfoForLine(text: *i8) {
    front := cast(*u8) text;

    initialState := stateFor(front);
    initialIsEmoji := initialState[0];

    front += cast(i64) initialState[1];

    runLength := 1;
    while ^front != cast(u8) "\0"[0] {
        state := stateFor(front);
        if state[0] != initialIsEmoji {
            return {initialIsEmoji, cast(*i8) front, cast(i32) (front - cast(*u8) text), runLength};
        }

        front += cast(i64) state[1];
        runLength += 1;
    }

    return {initialIsEmoji, cast(*i8) front, cast(i32) (front - cast(*u8) text), runLength};
}

fn drawLine(formId: i64, formData: *TextEditFormData, line: i64, offset: *gui.Rect!(f64)) {
    form := &context.forms.buf[formId];

    -- Add text and lay it out
    lastChar := se.editor_buffer_get_line_length(context.tc.eb, line);

    text := se.editor_buffer_get_text_between_points(context.tc.eb, line, 0, line, lastChar);
    defer { se.editor_buffer_free_buf(text); }

    x: f64 = 5 - offset.x;
    y: f64 = cast() (cast() FONT_SIZE * (line + 1)) - offset.y;

    -- try to find the cachedLine. If we can't make a new one
    if formData.lineCache.buf.count <= line {
        cl: CachedLine = {cast() (context.sdl.windowHeight + 10), 0, buf.make!(gui.Rect!(f64))()};
        &formData.lineCache|:set(line, cl);
        formData.lineCache.buf.count = line + 1;
    }
    cl := &formData.lineCache.buf[line];

    glyphIndex := 0;

    front := text.bytes;
    while ^front != "\0"[0] {
        -- Reset HarfBuzz buffer
        hb.hb_buffer_reset(context.hb.buffer);

        -- Set buffer to LTR direction, common script and default language
        hb.hb_buffer_set_direction(context.hb.buffer, hb.HB_DIRECTION_LTR);
        hb.hb_buffer_set_script(context.hb.buffer, hb.HB_SCRIPT_COMMON);
        hb.hb_buffer_set_language(context.hb.buffer, hb.hb_language_get_default());

        runInfo := runInfoForLine(front);

        hb.hb_buffer_add_utf8(context.hb.buffer, text.bytes, -1, cast() (front - text.bytes), runInfo[2]);
        -- hb.hb_buffer_add_utf8(context.hb.buffer, text.bytes, -1, 0, -1);

        front = runInfo[1];

        if runInfo[0] == true {
            hb.hb_shape(context.hb.emojiFont, context.hb.buffer, nil, 0);
        }
        else {
            hb.hb_shape(context.hb.font, context.hb.buffer, nil, 0);
        }

        -- Get buffer data
        glyphCount := hb.hb_buffer_get_length(context.hb.buffer);

        glyphInfo := hb.hb_buffer_get_glyph_infos(context.hb.buffer, nil);
        glyphPos := hb.hb_buffer_get_glyph_positions(context.hb.buffer, nil);

        if glyphCount == 0 { return; }

        -- todo(chad): @Performance -- I was able to get up past 1k glyphs in release interpreter doing this,
        -- but in theory for high glyph counts it's not the best to walk through each one if we're scrolled very far to the right
        -- just to figure out where to start drawing. Maybe some info in LineCache for every 500 glyphs or something on where the start x position is
        -- for that group of 500, that way we can skip 500 at a time.
        for i: iter.until(cast() glyphCount) {
            found := findGlyph(formData, cast() (glyphInfo + i).codepoint, runInfo[0]);

            if x + found.extents.xAdvance >= 0 {
                cairo.cairo_save(form.layer.context);
                cairo.cairo_translate(form.layer.context, x, y + found.extents.yBearing);

                cairo.cairo_set_source(form.layer.context, found.pattern);
                cairo.cairo_rectangle(form.layer.context,
                    found.extents.xBearing,
                    0,
                    cast() (found.extents.width + 1),
                    cast() (found.extents.height + 1));
                cairo.cairo_fill(form.layer.context);

                if y + found.extents.yBearing < cl.low {
                    cl.low = offset.y + y + found.extents.yBearing;
                }
                if y + found.extents.yBearing + cast() (found.extents.height + 1) > cl.high {
                    cl.high = offset.y + y + found.extents.yBearing + found.extents.height + 1;
                }

                &cl.glyphs|:set(glyphIndex + i, {
                    offset.x + x + found.extents.xBearing,
                    offset.y + y + found.extents.yBearing,
                    cast() (found.extents.width + 1),
                    cast() (found.extents.height + 1)
                });

                cairo.cairo_restore(form.layer.context);
            }

            x += found.extents.xAdvance;
        }

        glyphIndex += cast() glyphCount;
    }
}

type TextEditFormData struct {
    highlights: buf.Buffer!(gui.Rect!(f64)),
    currentMousePoint: struct{row: i64, col: i64},

    glyphCache: buf.Buffer!(CachedGlyph),
    lineCache: buf.Buffer!(CachedLine),
}

fn cursorIterator() {
    type CursorIterator struct{
        current: i64,
        count: i64
    }

    #attr(CursorIterator) {
        fn empty(ci: CursorIterator) {
            return ci.current >= ci.count;
        }

        fn front(ci: CursorIterator) {
            return ^(context.tc.eb.currentScreen.cursorInfos.buf + ci.current);
        }

        fn popFront(ci: *CursorIterator) {
            ci.current += 1;
        }
    }

    return cast(CursorIterator) { 0, context.tc.eb.currentScreen.cursorInfos.length };
}

type CursorFormData struct {
    parentRect: *gui.Rect!(f64),
    parentId: i64
}

fn makeCursor(formData: *TextEditFormData, parentId: i64) {
    fn draw(formId: i64, formData: *CursorFormData, messageData: *none) {
        form := &context.forms.buf[formId];

        parent := &context.forms.buf[formData.parentId];
        parentData := cast(*TextEditFormData) parent.data;

        for cursorInfo: cursorIterator() {
            cursorRect: gui.Rect!(f64);
            hasPrevious := false;

            width: f64 = 20.0;

            if parentData.lineCache.buf.count > cursorInfo.row {
                cl := parentData.lineCache.buf[cursorInfo.row];

                if cl.glyphs.buf.count >= cursorInfo.col {
                    hasPrevious = true;

                    g := cl.glyphs.buf[cursorInfo.col - 1];
                    form.rect = {formData.parentRect.x + g.x + g.width, formData.parentRect.y + cl.low - 1, width, cast() FONT_SIZE};
                }
            }
            if !hasPrevious {
                form.rect = {formData.parentRect.x, formData.parentRect.y + cast() (cast() cursorInfo.row * FONT_SIZE), width, cast() FONT_SIZE};
            }

            #import "time";
            elapsedSeconds := cast(f64) context.elapsed / cast() time.CLOCKS_PER_SEC;

            alpha := (math.sin(elapsedSeconds * 9) + 1.0) / 2.0;

            cairo.cairo_set_source_rgba(form.layer.context, 0.9, 0.9, 0.9, alpha);
            cairo.cairo_set_line_width(form.layer.context, 10);
            cairo.cairo_move_to(form.layer.context, 0, 0);
            cairo.cairo_line_to(form.layer.context, 0, 100);
            cairo.cairo_stroke(form.layer.context);
        }
    }

    -- todo(chad): wtf...
    if false { return 0; }

    parent := &context.forms.buf[parentId];
    cfd: CursorFormData = {&parent.rect, parentId};

    formId := gui.makeFormNonScaled({0, 0, 1.5, cast(f64) FONT_SIZE}, cfd, true);
    formId|gui.addReceiver(gui.DRAW, draw);
    &context.animators|:append(formId);
    return formId;
}

fn loadFonts() {
    emojiFont := "/System/Library/Fonts/Apple Color Emoji.ttc";
    -- font := "/System/Library/Fonts/Apple Color Emoji.ttc";

    -- font := "/Users/chadrussell/Projects/text/Noto-unhinted/NotoColorEmoji.ttf";
    -- font := "/Users/chadrussell/Projects/text/emojione-apple.ttc";
    -- font := "/Users/chadrussell/Library/Fonts/Roboto-Light.ttf";
    font := "/Library/Fonts/Inconsolata.otf";
    -- font := "/Users/chadrussell/Projects/text/JFWilwod.ttf";

    -- emojiMonkey := "ðŸ™ˆ";

    -- For CAIRO, load using FreeType
    ftLibrary: ft.Library;
    ft.FT_Init_FreeType(&ftLibrary);
    ftFace: ft.Face;

    err := ft.FT_New_Face(ftLibrary, font|string.cstr, 0, &ftFace);
    if err != 0 {
        io.println("error creating freetype font face");
        panic();
    }
    context.cairo.font = cairo.cairo_ft_font_face_create_for_ft_face(ftFace, 0);

    err = ft.FT_New_Face(ftLibrary, emojiFont|string.cstr, 0, &ftFace);
    if err != 0 {
        io.println("error creating freetype emoji font face");
        panic();
    }
    context.cairo.emojiFont = cairo.cairo_ft_font_face_create_for_ft_face(ftFace, 0);

    -- For Harfbuzz, load using OpenType (HarfBuzz FT does not support bitmap font)
    blob := hb.hb_blob_create_from_file(font|string.cstr);
    face := hb.hb_face_create(blob, 0);
    context.hb.font = hb.hb_font_create(face);
    hb.hb_ot_font_set_funcs(context.hb.font);
    hb.hb_font_set_scale(context.hb.font, FONT_SIZE * 64, FONT_SIZE * 64);

    blob = hb.hb_blob_create_from_file(emojiFont|string.cstr);
    face = hb.hb_face_create(blob, 0);
    context.hb.emojiFont = hb.hb_font_create(face);
    hb.hb_ot_font_set_funcs(context.hb.emojiFont);
    hb.hb_font_set_scale(context.hb.emojiFont, FONT_SIZE * 64, FONT_SIZE * 64);

    context.hb.buffer = hb.hb_buffer_create();
}

fn make(rect: gui.Rect!(f64)) {
    #import "random";
    random.seed();

    fn draw(formId: i64, formData: *TextEditFormData, messageData: *gui.Rect!(f64)) {
        form := &context.forms.buf[formId];

        -- clear
        formId|gui.drawRect(^messageData, 0.1739, 0.1867, 0.1433);
        -- formId|gui.drawRect({0, 0, form.rect.width, form.rect.height}, 0.1739, 0.1867, 0.1433);

        startLine := cast(i64) messageData.y / cast(i64) FONT_SIZE;
        if startLine < 0 { startLine = 0; }

        endLine := startLine + 2 + (cast(i64) messageData.height + 1) / cast(i64) FONT_SIZE;
        maxLine := se.editor_buffer_get_line_count(context.tc.eb);
        if endLine > maxLine {
            endLine = maxLine;
        }

        for line: iter.range(startLine, endLine) {
            drawLine(formId, formData, line, messageData);
        }

        for highlight: formData.highlights.buf {
            -- translate into our space
            highlight.x -= messageData.x;
            highlight.y -= messageData.y;

            formId|gui.drawRect(highlight, 0.9, 0.9, 0.9, 0.5);
        }
    }

    fn mousedown(formId: i64, formData: *TextEditFormData, messageData: *gui.MouseMessageData) {
        se.editor_buffer_set_cursor_point(context.tc.eb, formData.currentMousePoint.row, formData.currentMousePoint.col);
    }

    fn mousemove(formId: i64, formData: *TextEditFormData, messageData: *gui.MouseMessageData) {
        form := &context.forms.buf[formId];

        oldCount := formData.highlights.buf.count;
        formData.highlights.buf.count = 0;

        localX := messageData.x - form.rect.x;
        localY := messageData.y - form.rect.y;

        -- Mouse cursor
        -- cursor: gui.Rect!(f64) = {cast() (localX - 10), cast() (localY - 10), 20, 20};
        -- &formData.highlights|:append(cursor);
        -- gui.setFormNeedsDraw(formId);

        -- y relative to the form
        line := cast(i64) (cast() localY / FONT_SIZE);

        if line >= 0 and line < formData.lineCache.buf.count {
            cl := formData.lineCache.buf[line];

            for g, i: cl.glyphs.buf {
                boundingLeft: gui.Rect!(f64) = {form.rect.x + g.x, form.rect.y + cl.low - 1, g.width/2, cast() FONT_SIZE};
                boundingRight: gui.Rect!(f64) = {form.rect.x + g.x + g.width/2, form.rect.y + cl.low - 1, g.width/2, cast() FONT_SIZE};

                if boundingLeft|:contains(messageData.x, messageData.y) {
                    formData.currentMousePoint = {line, i};

                    clG := cl.glyphs.buf[i - 1];
                    if i > 0 {
                        cursorRect: gui.Rect!(f64) = {clG.x + clG.width, cl.low - 1, 2, cast() FONT_SIZE};

                        &formData.highlights|:append(cursorRect);
                        gui.setFormNeedsDraw(formId);
                    }
                    else {
                        cursorRect: gui.Rect!(f64) = {cl.glyphs.buf[0].x, cl.low - 1, 2, cast() FONT_SIZE};

                        &formData.highlights|:append(cursorRect);
                        gui.setFormNeedsDraw(formId);
                    }
                }
                else if boundingRight|:contains(messageData.x, messageData.y) {
                    formData.currentMousePoint = {line, i + 1};

                    cursorRect: gui.Rect!(f64) = {g.x + g.width, cl.low - 1, 2, cast() FONT_SIZE};

                    &formData.highlights|:append(cursorRect);
                    gui.setFormNeedsDraw(formId);
                }
            }

            -- entire line
            -- lineRect: gui.Rect!(f64) = {0, cl.low - 1, cast() context.sdl.windowWidth, cl.high - cl.low + 2};
            -- &formData.highlights|:append(lineRect);
        }
        else if oldCount != formData.highlights.buf.count {
            gui.setFormNeedsDraw(formId);
        }
    }

    fn keydown(formId: i64, formData: *TextEditFormData, messageData: *gui.KeyboardMessageData) {
        gui.broadcast(TEXT_UPDATE);

        if messageData.scancode == sdl.Key.BACKSPACE {
            se.editor_buffer_set_cursor_is_selection(context.tc.eb, 1);
            se.editor_buffer_set_cursor_pos_relative(context.tc.eb, -1);
            se.editor_buffer_delete(context.tc.eb);
            se.editor_buffer_set_cursor_is_selection(context.tc.eb, 0);
        }
        else if messageData.scancode == sdl.Key.SPACE {
            se.editor_buffer_insert(context.tc.eb, " \0".data);
        }
        else if messageData.scancode == sdl.Key.ENTER {
            se.editor_buffer_insert(context.tc.eb, "\n\0".data);
        }
        else if messageData.scancode == sdl.Key.LEFT {
            se.editor_buffer_set_cursor_pos_relative(context.tc.eb, -1);
        }
        else if messageData.scancode == sdl.Key.RIGHT {
            se.editor_buffer_set_cursor_pos_relative(context.tc.eb, 1);
        }
        else if messageData.scancode == sdl.Key.UP {
            for ci: iter.withIndex(cursorIterator()) {
                se.editor_buffer_set_cursor_point_for_cursor_index(context.tc.eb, ci.index, ci.it.row - 1, ci.it.col);
            }
        }
        else if messageData.scancode == sdl.Key.DOWN {
            for ci: iter.withIndex(cursorIterator()) {
                se.editor_buffer_set_cursor_point_for_cursor_index(context.tc.eb, ci.index, ci.it.row + 1, ci.it.col);
            }
        }
        else if messageData.scancode|:isalpha {
            if messageData.scancode == cast() 8 {
                se.editor_buffer_insert(context.tc.eb, "ðŸ™ˆ\0".data);
            }
            else {
                se.editor_buffer_insert(context.tc.eb, :charsFor(messageData.scancode));
            }
        }
    }

    fn textUpdate(formId: i64, formData: *TextEditFormData, messageData: *none) {
        formData.lineCache.buf.count = 0;
        formId|gui.setFormNeedsDraw;
    }

    formData: TextEditFormData;

    formId := gui.makeForm(rect, formData, ownLayer: true);

    formId|gui.addReceiver(gui.DRAW, draw);
    formId|gui.addReceiver(gui.MOUSEMOVE, mousemove);
    formId|gui.addReceiver(gui.MOUSEDOWN, mousedown);
    formId|gui.addReceiver(gui.KEYDOWN, keydown);
    formId|gui.addReceiver(TEXT_UPDATE, textUpdate);

    &context.mousers|:append(formId);
    &context.texters|:append(formId);

    return formId;
}
