#import "gui/gui";
#import "gui/track";
#import "gui/trackContainer";
#import "gui/scroller";
#import "io";
#import "buffer": buf;
#import "sdl";
#import "math";

grabberRadius: f64 = 15;
grabberMaxSize: f64 = 10;

type PlayAreaFormData struct {
    compositionLength: f64,
    playing: bool,
    playhead: f64,
    playheadGrabber: f64,
    draggingPlayhead: bool,
    tracks: buf.Buffer!(trackContainer.TrackContainerFormData),
    horizontalScroller: scroller.Data,
    verticalScroller: scroller.Data,
    addNewTrackButton: gui.Rect!(f64),
}

fn mouseButtonDown(messageData: *sdl.MouseButtonEvent) {
    if context.state.playArea.playheadGrabber > 0 {
        context.state.playArea.draggingPlayhead = true;
        return;
    }

    if context.state.playArea.horizontalScroller.rect|gui.containsMouse {
        scroller.mouseButtonDown(messageData, &context.state.playArea.horizontalScroller);
        return;
    }
    if context.state.playArea.verticalScroller.rect|gui.containsMouse {
        scroller.mouseButtonDown(messageData, &context.state.playArea.verticalScroller);
        return;
    }

    if context.state.playArea.addNewTrackButton|gui.containsMouse {
        tr: trackContainer.TrackContainerFormData;
        &context.state.playArea.tracks|:append(tr);
        return;
    }

    for tr, i: context.state.playArea.tracks.buf {
        if tr.rect|gui.containsMouse {
            trackContainer.mouseButtonDown(messageData, i);
            return;
        }
    }
}

fn mouseButtonUp(messageData: *sdl.MouseButtonEvent) {
    context.state.playArea.draggingPlayhead = false;

    scroller.mouseButtonUp(&context.state.playArea.horizontalScroller);
    scroller.mouseButtonUp(&context.state.playArea.verticalScroller);

    for tr, i: context.state.playArea.tracks.buf {
        if tr.bounds|gui.containsMouse {
            track.mouseButtonUp(messageData, i);
        }
    }
}

fn mouseMove(messageData: *sdl.MouseMotionEvent) {
    if context.state.playArea.draggingPlayhead == true {
        context.state.playArea.playheadGrabber = cast() messageData.y;
        context.state.playArea.playhead = cast() messageData.x;
        return;
    }

    scroller.mouseMove(&context.state.playArea.horizontalScroller);
    scroller.mouseMove(&context.state.playArea.verticalScroller);

    if math.abs(cast() messageData.x - context.state.playArea.playhead) < grabberRadius {
        context.state.playArea.playheadGrabber = cast() messageData.y;
    }
    else {
        context.state.playArea.playheadGrabber = -1;

        for tr, i: context.state.playArea.tracks.buf {
            if tr.rect|gui.contains(cast(f64) messageData.x, cast(f64) messageData.y) {
                track.mouseMove(messageData, i);
            }
        }
    }
}

fn keydown(messageData: *sdl.KeyboardEvent) {
    if messageData.keysym.scancode == sdl.Key.SPACE {
        context.state.playArea.playing = !context.state.playArea.playing;
    }
    else if messageData.keysym.scancode == sdl.Key.LEFT {
        io.println("left");
        context.state.playArea.playhead = 0;
    }
}

fn processMessages() {
    if context.keyDownEvent != nil {
        keydown(context.keyDownEvent);
    }
    if context.mouseButtonDownEvent != nil {
        mouseButtonDown(context.mouseButtonDownEvent);
    }
    if context.mouseButtonUpEvent != nil {
        mouseButtonUp(context.mouseButtonUpEvent);
    }
    if context.mouseMotionEvent != nil {
        mouseMove(context.mouseMotionEvent);
    }
}

fn draw(rect: gui.Rect!(f64)) {
    -- background
    gui.drawRect(context.cairo.layer, rect, cast(f64) 67.0/255.0, cast(f64) 77.0/255.0, cast(f64) 82.0/255.0);

    y: f64 = 0;

    -- scroll/resize bar
    srHeight: f64 = 25;
    scroller.drawHorizontal({0, y, rect.width - srHeight, srHeight}, &context.state.playArea.horizontalScroller);
    y += srHeight;

    -- vertical scroll/resize bar
    scroller.drawVertical({rect.width-srHeight, srHeight, srHeight, rect.height - srHeight}, &context.state.playArea.verticalScroller);

    metaMargin := rect.width*0.05;
    grButtonHeight := rect.height * 0.1;

    -- graph rolls
    vs := &context.state.playArea.verticalScroller;
    yScale := vs.rect.height / (vs.end - vs.begin);

    trackScrollViewHeight := rect.height - y;

    grAreaBounds: gui.Rect!(f64) = rect;
    grAreaBounds.y = y;
    grAreaBounds.height = trackScrollViewHeight;
    grAreaBounds.width -= srHeight;

    grHeight := trackScrollViewHeight / cast() context.state.playArea.tracks.buf.count * yScale;

    percScrolled := scroller.percScrolled(vs);

    maxOffset := trackScrollViewHeight * yScale - trackScrollViewHeight;

    for gr, grIndex: context.state.playArea.tracks.buf {
        scrollOffsetY := percScrolled * maxOffset;
        trackContainer.draw({rect.x, y - scrollOffsetY, rect.width - srHeight, grHeight}, grAreaBounds, grIndex, metaMargin);
        y += grHeight;
    }

    -- button to add graph roll
    context.state.playArea.addNewTrackButton = {10, rect.y + rect.height - grButtonHeight - 10, grButtonHeight, grButtonHeight};
    gui.drawRect(context.cairo.layer, context.state.playArea.addNewTrackButton, 0.4, 0.4, 1);

    -- playhead
    context.cairo.layer|gui.drawRect({context.state.playArea.playhead, 0, 1, rect.height}, 1, 0.2, 0.2);
    if context.state.playArea.playing {
        context.state.playArea.playhead += 1;
    }

    -- playhead grabber
    if context.state.playArea.playheadGrabber > 0 {
        xDist: f64 = math.abs(context.mouse.x - context.state.playArea.playhead);
        grabberSize := math.min((xDist-15)*(xDist-15)/15, grabberMaxSize);

        context.cairo.layer|gui.drawRect({
            context.state.playArea.playhead - grabberSize/2,
            context.state.playArea.playheadGrabber - grabberSize/2,
            grabberSize,
            grabberSize
        }, 1, 0.2, 0.2);
    }
}
