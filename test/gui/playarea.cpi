#import "gui/gui";
#import "gui/track";
#import "gui/graphroll";
#import "gui/trackContainer";
#import "gui/scroller";
#import "io";
#import "buffer": buf;
#import "sdl";
#import "math";

grabberRadius: f64 = 15;
grabberMaxSize: f64 = 10;

type ScreenType enum {
    TrackList,
    Track
}

type PlayAreaFormData struct {
    playing: bool,
    playhead: f64,
    playheadGrabber: f64,
    draggingPlayhead: bool,
    tracks: buf.Buffer!(trackContainer.TrackContainerFormData),
    horizontalScroller: scroller.Data,
    verticalScroller: scroller.Data,
    addNewTrackButton: gui.Rect!(f64),

    screenType: ScreenType = ScreenType.TrackList,
    screenData: *none = nil,

    compositionLengthInMicroseconds: u64 = 60000000,
    beatsPerMinute: u32 = 120
}

fn mouseButtonDown(messageData: *sdl.MouseButtonEvent) {
    if context.state.playArea.playheadGrabber > 0 {
        context.state.playArea.draggingPlayhead = true;
        return;
    }

    if context.state.playArea.horizontalScroller.rect|gui.containsMouse {
        scroller.mouseButtonDown(messageData, &context.state.playArea.horizontalScroller);
        return;
    }
    if context.state.playArea.verticalScroller.rect|gui.containsMouse {
        scroller.mouseButtonDown(messageData, &context.state.playArea.verticalScroller);
        return;
    }

    if context.state.playArea.screenType == ScreenType.TrackList {
        if context.state.playArea.addNewTrackButton|gui.containsMouse {
            tr: trackContainer.TrackContainerFormData;
            &context.state.playArea.tracks|:append(tr);
            return;
        }

        for tr, i: context.state.playArea.tracks.buf {
            if tr.rect|gui.containsMouse {
                trackContainer.mouseButtonDown(messageData, i);
                return;
            }
        }
    }
    else if context.state.playArea.screenType == ScreenType.Track {
        clip := cast(*track.Clip) context.state.playArea.screenData;
        graphroll.mouseButtonDown(messageData, &clip.graphRoll);
    }
}

fn mouseButtonUp(messageData: *sdl.MouseButtonEvent) {
    context.state.playArea.draggingPlayhead = false;

    scroller.mouseButtonUp(&context.state.playArea.horizontalScroller);
    scroller.mouseButtonUp(&context.state.playArea.verticalScroller);

    if context.state.playArea.screenType == ScreenType.TrackList {
        for tr, i: context.state.playArea.tracks.buf {
            if tr.bounds|gui.containsMouse {
                track.mouseButtonUp(messageData, i);
            }
        }
    }
    else if context.state.playArea.screenType == ScreenType.Track {
        clip := cast(*track.Clip) context.state.playArea.screenData;
        graphroll.mouseButtonUp(messageData, &clip.graphRoll);
    }
}

fn mouseMove(messageData: *sdl.MouseMotionEvent) {
    if context.state.playArea.draggingPlayhead == true {
        context.state.playArea.playheadGrabber = cast() messageData.y;
        context.state.playArea.playhead = cast() messageData.x;
        return;
    }

    scroller.mouseMove(&context.state.playArea.horizontalScroller);
    scroller.mouseMove(&context.state.playArea.verticalScroller);

    if math.abs(cast() messageData.x - context.state.playArea.playhead) < grabberRadius {
        context.state.playArea.playheadGrabber = cast() messageData.y;
    }
    else if context.state.playArea.screenType == ScreenType.TrackList {
        context.state.playArea.playheadGrabber = -1;

        for tr, i: context.state.playArea.tracks.buf {
            if tr.rect|gui.contains(cast(f64) messageData.x, cast(f64) messageData.y) {
                track.mouseMove(messageData, i);
            }
        }
    }
    else if context.state.playArea.screenType == ScreenType.Track {
        clip := cast(*track.Clip) context.state.playArea.screenData;
        graphroll.mouseMove(messageData, &clip.graphRoll);
    }
}

fn keydown(messageData: *sdl.KeyboardEvent) {
    if messageData.keysym.scancode == sdl.Key.SPACE {
        context.state.playArea.playing = !context.state.playArea.playing;
    }
    else if messageData.keysym.scancode == sdl.Key.LEFT {
        io.println("left");
        context.state.playArea.playhead = 0;
    }
}

fn processMessages() {
    if context.keyDownEvent != nil {
        keydown(context.keyDownEvent);
    }
    if context.mouseButtonDownEvent != nil {
        mouseButtonDown(context.mouseButtonDownEvent);
    }
    if context.mouseButtonUpEvent != nil {
        mouseButtonUp(context.mouseButtonUpEvent);
    }
    if context.mouseMotionEvent != nil {
        mouseMove(context.mouseMotionEvent);
    }
}

fn draw(rect: gui.Rect!(f64)) {
    -- background
    gui.drawRect(context.cairo.layer, rect, cast(f64) 67.0/255.0, cast(f64) 77.0/255.0, cast(f64) 82.0/255.0);

    y: f64 = 0;

    -- scroll/resize bar
    srHeight: f64 = 25;
    scroller.drawHorizontal({0, y, rect.width - srHeight, srHeight}, &context.state.playArea.horizontalScroller);
    y += srHeight;

    -- vertical scroll/resize bar
    scroller.drawVertical({rect.width-srHeight, srHeight, srHeight, rect.height - srHeight}, &context.state.playArea.verticalScroller);

    trackScrollViewHeight := rect.height - y;

    trAreaBounds: gui.Rect!(f64) = rect;
    trAreaBounds.y = y;
    trAreaBounds.height = trackScrollViewHeight;
    trAreaBounds.width -= srHeight;

    vs := &context.state.playArea.verticalScroller;
    percScrolled := scroller.percScrolled(vs);
    yScale := vs.rect.height / (vs.end - vs.begin);
    maxOffset := trackScrollViewHeight * yScale - trackScrollViewHeight;
    scrollOffsetY := percScrolled * maxOffset;

    if context.keyDownEvent != nil
        and context.keyDownEvent.keysym.scancode == sdl.Key.ESCAPE
        and context.state.playArea.screenType == ScreenType.Track {
        context.state.playArea.screenType = ScreenType.TrackList;
    }

    if context.state.playArea.screenType == ScreenType.TrackList {
        trButtonHeight := rect.height * 0.1;

        -- graph rolls
        trHeight := trackScrollViewHeight / cast() context.state.playArea.tracks.buf.count * yScale;
        metaMargin := rect.width*0.05;

        for tr, trIndex: context.state.playArea.tracks.buf {
            trackContainer.draw({rect.x, y - scrollOffsetY, rect.width, trHeight}, trAreaBounds, trIndex, metaMargin);
            y += trHeight;
        }

        -- button to add track
        context.state.playArea.addNewTrackButton = {10, rect.y + rect.height - trButtonHeight - 10, trButtonHeight, trButtonHeight};
        gui.drawRect(context.cairo.layer, context.state.playArea.addNewTrackButton, 0.4, 0.4, 1);
    }
    else if context.state.playArea.screenType == ScreenType.Track {
        clip := cast(*track.Clip) context.state.playArea.screenData;

        graphRect: gui.Rect!(f64) = {rect.x, y - scrollOffsetY, rect.width - srHeight, rect.height * yScale};

        -- clip.rect.width is the number of beats
        clip.graphRoll.xResolution = graphRect.width / clip.rect.width;

        graphroll.draw(graphRect, trAreaBounds, &clip.graphRoll);
    }
    else {
        panic();
    }

    -- playhead
    context.cairo.layer|gui.drawRect({context.state.playArea.playhead, 0, 1, rect.height}, 1, 0.2, 0.2);
    if context.state.playArea.playing {
        context.state.playArea.playhead += 1;
    }

    -- playhead grabber
    if context.state.playArea.playheadGrabber > 0 {
        xDist: f64 = math.abs(context.mouse.x - context.state.playArea.playhead);
        grabberSize := math.min((xDist-15)*(xDist-15)/15, grabberMaxSize);

        context.cairo.layer|gui.drawRect({
            context.state.playArea.playhead - grabberSize/2,
            context.state.playArea.playheadGrabber - grabberSize/2,
            grabberSize,
            grabberSize
        }, 1, 0.2, 0.2);
    }
}
