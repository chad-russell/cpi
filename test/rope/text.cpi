#import "io";
#import "mem";
#import "buffer";
#import "string";
#import "iter";

SPLIT_THRESHOLD := 2048 * 4;
COPY_THRESHOLD  := 2048 * 4;

type StringBuf struct {
    length: u64,
    capacity: u64,
    bytes: *i8,

    rc: i32
}

#attr(StringBuf) {
fn release(buf: *StringBuf) {
    if buf == nil { return; }

    if buf.rc > 0 {
        buf.rc -= 1;
    } else {
        mem.free(buf.bytes);
    }

    mem.free(buf);
}
}

type Rope struct {
    byteWeight: u64,
    totalByteWeight: u64,

    charWeight: u64,
    totalCharWeight: u64,

    lineBreakWeight: u64,
    totalLineBreakWeight: u64,

    isLeaf: bool,
    rc: i32,

    d: struct {
        left: *Rope,
        right: *Rope
    }
}

fn children(r: *Rope) {
    return r.d;
}

fn data(r: *Rope) {
    return cast(*StringBuf) r.d.left;
}

fn countNewlines(s: *i8) u64 {
    if s == nil { return 0; }

    count: u64 = 0;

    c := s;
    while ^c != "\0"[0] {
        if ^c == "\n"[0] { count += 1; }
        c += 1;
    }

    return count;
}

fn setRight(target: *Rope, newRight: *Rope) {
    if newRight == children(target).right { return; }

    children(target).right|decRc;
    children(target).right = newRight;
    newRight|incRc;

    totalByteWeight(target);
    totalLineBreakWeight(target);
    totalCharWeight(target);
}

fn setLeft(target: *Rope, newLeft: *Rope) {
    if newLeft == children(target).left { return; }

    children(target).left|decRc;
    children(target).left = newLeft;
    newLeft|incRc;

    target.byteWeight = byteWeight(target);
    totalByteWeight(target);

    target.charWeight = charWeight(target);
    totalCharWeight(target);

    target.lineBreakWeight = lineBreakWeight(target);
    totalLineBreakWeight(target);
}

fn totalByteLength(rn: *Rope) u64 {
    if rn == nil { return 0; }

    return rn.totalByteWeight;
}

fn byteWeight(rn: *Rope) u64 {
    if rn == nil { return 0; }

    if rn.isLeaf {
        return rn.byteWeight;
    }

    return totalByteLength(children(rn).left);
}

fn totalByteWeight(rn: *Rope) u64 {
    if rn == nil { return 0; }

    if children(rn).left != nil and children(rn).right != nil {
        rn.totalByteWeight = children(rn).left.totalByteWeight + children(rn).right.totalByteWeight;
    }
    else if children(rn).left != nil {
        rn.totalByteWeight = children(rn).left.totalByteWeight;
    } else if children(rn).right != nil {
        rn.totalByteWeight = children(rn).right.totalByteWeight;
    } else {
        rn.totalByteWeight = 0;
    }

    return rn.totalByteWeight;
}

fn totalCharLength(rn: *Rope) u64 {
    if rn == nil { return 0; }

    return rn.totalCharWeight;
}

fn charWeight(rn: *Rope) u64 {
    if rn == nil { return 0; }

    if rn.isLeaf {
        return rn.charWeight;
    }

    return totalCharLength(children(rn).left);
}

fn totalCharWeight(rn: *Rope) u64 {
    if rn == nil { return 0; }

    if children(rn).left != nil and children(rn).right != nil {
        rn.totalCharWeight = children(rn).left.totalCharWeight + children(rn).right.totalCharWeight;
    }
    else if children(rn).left != nil {
        rn.totalCharWeight = children(rn).left.totalCharWeight;
    } else if children(rn).right != nil {
        rn.totalCharWeight = children(rn).right.totalCharWeight;
    } else {
        rn.totalCharWeight = 0;
    }

    return rn.totalCharWeight;
}

fn totalLineBreakLength(rn: *Rope) u64 {
    if rn == nil { return 0; }

    return rn.totalLineBreakWeight;
}

fn lineBreakWeight(rn: *Rope) u64 {
    if rn == nil { return 0; }

    if rn.isLeaf {
        return countNewlines(data(rn).bytes);
    }

    return totalLineBreakLength(children(rn).left);
}

fn totalLineBreakWeight(rn: *Rope) u64 {
    if rn == nil { return 0; }

    if children(rn).left != nil and children(rn).right != nil {
        rn.totalLineBreakWeight = children(rn).left.totalLineBreakWeight + children(rn).right.totalLineBreakWeight;
    }
    else if children(rn).left != nil {
        rn.totalLineBreakWeight = children(rn).left.totalLineBreakWeight;
    } else if children(rn).right != nil {
        rn.totalLineBreakWeight = children(rn).right.totalLineBreakWeight;
    } else {
        rn.totalLineBreakWeight = 0;
    }

    return rn.totalLineBreakWeight;
}

fn printRope(r: *Rope) {
    if r == nil { return; }

    if r.isLeaf {
        s: []i8;
        s.data = data(r).bytes;
        s.count = cast() data(r).length;

        io.print(s);
    }
    else {
        printRope(children(r).left);
        io.print("|");
        printRope(children(r).right);
    }
}

fn incRc(rn: *Rope)
{
    if rn == nil { return; }

    rn.rc += 1;
}

fn decRc(rn: *Rope) {
    if rn == nil { return; }

    basic.assert(rn.rc > 0);

    rn.rc -= 1;
    if rn.rc == 0 {
        releaseRope(rn);
    }
}

-- todo(chad): why can we not put this behind #attr(Rope) and just call it release??
fn releaseRope(rn: *Rope) {
    if rn == nil { return; }
    if rn.rc != 0 { return; }

    rn.rc = -1;
    if !rn.isLeaf {
        children(rn).left|decRc;
        children(rn).right|decRc;
    }
    else {
        :release(data(rn));
    }

    mem.free(rn);
}

#context ropeId: u64

fn makeNode(isLeaf: bool, byteWeight: u64, charWeight: u64) {
    context.ropeId += 1;

    rn := mem.alloc!(Rope)(1);

    if isLeaf {
        rn.d.left = cast() mem.alloc!(StringBuf)();
    }

    rn.rc = 0;
    rn.isLeaf = isLeaf;

    rn.byteWeight = byteWeight;
    rn.totalByteWeight = byteWeight;

    rn.charWeight = charWeight;
    rn.totalCharWeight = charWeight;

    return rn;
}

fn makeParent(left: *Rope, right: *Rope) {
    rn := makeNode(false, byteWeight(left), charWeight(left));

    rn|setLeft(left);
    rn|setRight(right);

    rn.byteWeight = byteWeight(rn);
    rn.totalByteWeight = totalByteWeight(rn);

    rn.charWeight = charWeight(rn);
    rn.totalCharWeight = totalCharWeight(rn);

    rn.lineBreakWeight = lineBreakWeight(rn);
    rn.totalLineBreakWeight = totalLineBreakWeight(rn);

    return rn;
}

type LineHelper struct {
    lines: buffer.Buffer!(u64),
    leftover: u64
}

fn countNewlinesLength(str: []i8, i: u64, lineHelper: *LineHelper) {
    newlineCount: u64 = 0;
    length: u64 = 0;

    cIdx := 0;
    while cIdx < str.count {
        if str[cIdx] == "\n"[0] {
            if lineHelper != nil {
                lineLength := lineHelper.leftover + 1;
                &lineHelper.lines | :append(lineLength);
                lineHelper.leftover = 0;
            }

            newlineCount += 1;
        }

        if lineHelper != nil {
            lineHelper.leftover += 1;
        }

        cIdx += string.bytesInCodepointUtf8(cast() str[cIdx]);
    }

    return newlineCount;
}

fn makeLeafWithLength(text: []i8, byteLength: u64, charLength: u64, lineHelper: *LineHelper) *Rope {
    if charLength > cast() SPLIT_THRESHOLD {
        half := charLength / 2;

        halfIdx: u64 = 0;
        for i: iter.until(cast() half) {
            -- todo(chad): should probably allow indexing by a u64...
            halfIdx += cast() string.bytesInCodepointUtf8(cast() text[cast(i64) halfIdx]);
        }

        firstHalfByteLength := halfIdx;

        left := makeLeafWithLength(text, firstHalfByteLength, half, lineHelper);
        right := makeLeafWithLength(string.subStr(text, cast() firstHalfByteLength), byteLength - firstHalfByteLength, charLength - half, lineHelper);

        return makeParent(left, right);
    }

    rn := makeNode(true, cast() text.count, charLength);
    data(rn).length = byteLength;
    data(rn).capacity = byteLength;
    data(rn).bytes = mem.alloc!(i8)(cast() byteLength);
    mem.memcpy(dst: data(rn).bytes, src: text.data, cast() byteLength);
    data(rn).rc = 0;

    type StringBuf struct {
        length: u64,
        capacity: u64,
        bytes: *i8,

        rc: i32
    }

    rn.lineBreakWeight = countNewlinesLength(text, charLength, lineHelper);
    rn.totalLineBreakWeight = rn.lineBreakWeight;

    return rn;
}

fn makeLeaf(text: []i8) {
    return makeLeafWithLength(text, cast() text.count, string.strlenUtf8(text), nil);
}

fn charAt(rn: *Rope, i: u64) *i8 {
    if rn == nil { return nil; }

    if rn.isLeaf {
        if rn.charWeight - 1 < i {
            return nil;
        }

        byteOffset := 0;
        for j: iter.until(cast() i) {
            byteOffset += string.bytesInCodepointUtf8(cast() ^(data(rn).bytes + byteOffset));
        }

        return data(rn).bytes + byteOffset;
    }

    if rn.charWeight - 1 < i {
        return charAt(children(rn).right, i - rn.charWeight);
    }
    else if children(rn).left != nil {
        return charAt(children(rn).left, i);
    }

    return nil;
}

fn shallowCopy(rn: *Rope) *Rope {
    if rn == nil { return nil; }

    copy := mem.alloc!(Rope)();
    mem.memcpy(dst: copy, src: rn, sizeof(Rope));

    copy.rc = 0;

    if !rn.isLeaf {
        incRc(children(rn).left);
        incRc(children(rn).right);
    } else {
        copy.d = rn.d;
        data(copy).rc += 1;
    }

    return copy;
}

fn split(rn: *Rope, i: u64, outNewLeft: **Rope, outNewRight: **Rope) {
    if rn.isLeaf {
        if i <= 0 {
            ^outNewLeft = nil;
            ^outNewRight = shallowCopy(rn);
        } else if i >= rn.charWeight {
            ^outNewLeft = shallowCopy(rn);
            ^outNewRight = nil;
        } else {
            byteOffset := 0;

            for j: iter.until(cast() i) {
                byteOffset += string.bytesInCodepointUtf8(cast() ^(data(rn).bytes + byteOffset));
            }

            rightSubstring: []i8;
            rightSubstring.data = data(rn).bytes + byteOffset;
            rightSubstring.count = cast(i64) data(rn).length - byteOffset;
            ^outNewRight = makeLeaf(rightSubstring);

            newLeftStr: []i8;
            newLeftStr.data = data(rn).bytes;
            newLeftStr.count = byteOffset;

            ^outNewLeft = makeLeaf(newLeftStr);
        }
    }
    else {
        rnCopy := shallowCopy(rn);
        usedRnCopy := false;

        if i < rnCopy.charWeight {
            rnCopy|setRight(nil);

            newGtLeft: *Rope;
            newGtRight: *Rope;
            children(rnCopy).left|split(i, &newGtLeft, &newGtRight);

            ^outNewRight = concat(newGtRight, children(rn).right);

            rnCopy|setLeft(newGtLeft);

            ^outNewLeft = rnCopy;
            usedRnCopy = true;

            outNewLeft.byteWeight = byteWeight(^outNewLeft);
            outNewLeft.totalByteWeight = totalByteWeight(^outNewLeft);

            outNewLeft.charWeight = charWeight(^outNewLeft);
            outNewLeft.totalCharWeight = totalCharWeight(^outNewLeft);

            outNewLeft.lineBreakWeight = lineBreakWeight(^outNewLeft);
            outNewLeft.totalLineBreakWeight = totalLineBreakWeight(^outNewLeft);
        }
        else if i > rnCopy.charWeight {
            newGtLeft: *Rope;
            newGtRight: *Rope;

            children(rn).right|split(i - rnCopy.charWeight, &newGtLeft, &newGtRight);

            rnCopy|setRight(newGtLeft);

            ^outNewLeft = rnCopy;
            usedRnCopy = true;

            ^outNewRight = newGtRight;
        }
        else {
            ^outNewLeft = shallowCopy(children(rnCopy).left);
            ^outNewRight = shallowCopy(children(rnCopy).right);
        }

        if !usedRnCopy {
            releaseRope(rnCopy);
        }
    }
}

fn makeLeafConcat(left: *Rope, right: *Rope) {
    rn := makeNode(true, left.byteWeight + right.byteWeight, left.charWeight + right.charWeight);

    data(rn).length = data(left).length + data(right).length;
    data(rn).capacity = data(rn).length;
    data(rn).bytes = mem.alloc!(i8)(cast() data(rn).length);
    mem.memcpy(dst: data(rn).bytes, src: data(left).bytes, cast() data(left).length);
    mem.memcpy(dst: data(rn).bytes + cast(i64) data(left).length, src: data(right).bytes, cast() data(right).length);
    data(rn).rc = 0;

    rn.lineBreakWeight = countNewlines(data(rn).bytes);
    rn.totalLineBreakWeight = rn.lineBreakWeight;

    releaseRope(left);
    releaseRope(right);

    return rn;
}

fn concat(left: *Rope, right: *Rope) {
    if right == nil {
        return left;
    }
    if left == nil {
        return right;
    }

    if right.isLeaf {
        if left.isLeaf {
            if left.byteWeight + right.byteWeight < COPY_THRESHOLD {
                cat := left|makeLeafConcat(right);
                return cat;
            }
        }
        else if children(left).right == nil {
            left|setRight(right);
            return left;
        }
        else if children(left).right.isLeaf and children(left).right.byteWeight + right.byteWeight < COPY_THRESHOLD {
            left|setRight(makeLeafConcat(children(left).right, right));
            return left;
        }
    }

    return makeParent(left, right);
}

fn insert(rn: *Rope, i: u64, text: []i8) {
    splitLeft: *Rope;
    splitRight: *Rope;
    split(rn, i, &splitLeft, &splitRight);

    insert := makeLeaf(text);
    combinedLeft := concat(splitLeft, insert);
    cat := concat(combinedLeft, splitRight);

    return cat;
}

fn delete(rn: *Rope, start: u64, end: u64) {
    if totalCharLength(rn) == 1 {
        return makeLeaf("");
    }

    splitEndLeft: *Rope;
    splitEndRight: *Rope;

    rn|split(end, &splitEndLeft, &splitEndRight);

    splitStartLeft: *Rope;
    splitStartRight: *Rope;

    splitEndLeft|split(start, &splitStartLeft, &splitStartRight);

    result := concat(splitStartLeft, splitEndRight);

    releaseRope(splitEndLeft);
    releaseRope(splitStartRight);

    return result;
}

fn test() {
    r := makeLeaf("hello, world!");

    inserted := r|insert(6, "X ");
    deleted := r|delete(2, 5);

    printRope(r);
    puts("\n");
    printRope(inserted);
    puts("\n");
    printRope(deleted);
    puts("\n");

    puts("\n");
}