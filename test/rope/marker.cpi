#import "mem";
#import "buffer": buf;
#import "io";
#import "string";
#import "iter";
#import "list";

type MarkerType enum(u8) {
    newline,
    custom
}

type Marker struct {
    _type: MarkerType,
    name: []i8
}

type Node struct {
    parent: bool,

    weight: u64,

    children: struct {
        left: *Node,
        right: *Node
    }
}

fn children(n: *Node) {
    basic.assert(n.parent);
    return n.children;
}

fn markers(n: *Node) {
    return cast(*list.List!(Marker)) n.children.left;
}

fn weight(n: *Node) u64 {
    if n == nil { return 0; }
    return n.weight;
}

fn makeParent(left: *Node, right: *Node) {
    p := mem.alloc!(Node)();

    p.parent = true;
    p.weight = weight(left) + weight(right);
    p.children = {left, right};

    if left == nil and right != nil {
        p.children.left = right;
        p.children.right = nil;
    }

    if p.children.left == nil {
        panic();
    }

    return p;
}

fn makeChild(markers: *list.List!(Marker), weight: u64 = 0) {
    p := mem.alloc!(Node)();

    p.parent = false;
    p.weight = weight;
    p.children.left = cast() markers;

    return p;
}

-- todo(chad): when inserting a newline for example -- does the length grow? probably not
-- i.e. if we have regions [[0,10]] and we add a newline character at 7 (so split at 7) we should probably get [[0,7], [7,10]]
fn split(n: *Node, at: u64, _type: MarkerType) {

}

fn nodeForCharAt(n: *Node, at: u64) {
    if n == nil { return n; }

    if n.parent {
        if n.children.left == nil {
            return nodeForCharAt(n.children.right, at);
        }
        else if n.children.right == nil {
            return nodeForCharAt(n.children.left, at);
        }

        if at <= n.children.left.weight {
            return nodeForCharAt(n.children.left, at);
        }

        return nodeForCharAt(n.children.right, at - n.children.left.weight);
    }

    if at > n.weight {
        return nil;
    }

    return n;
}

fn insertText(n: *Node, at: u64, len: u64) *Node {
    if n == nil { return n; }

    if n.parent {
        if at <= n.children.left.weight {
            return makeParent(insertText(n.children.left, at, len), n.children.right);
        }

        return makeParent(n.children.left, insertText(n.children.right, at, len));
    }
    else if at <= n.weight {
        return makeChild(markers(n), n.weight + len);
    }

    return makeChild(list.empty!(Marker)(), len);
}

-- todo(chad)
fn split(n: *Node, at: u64) {
    if !n.parent {
        if at == 0 or at >= n.weight {
            return n;
        }
    }
}

-- todo(chad)
fn merge(l: *Node, r: *Node) {
}

-- todo(chad)
fn deleteText(n: *Node, at: u64, len: u64) {
    -- todo(chad): possible implementation:
        -- find node at `at`, and node at `at + len`.
            -- If they're the same node, then we simply need to adjust the weight of that node.
            -- If they're not the same node, then we need to split the tree at the start and end nodes, and then rejoin it.
                -- We need to detect if the deleted range spans the beginning/end of any markers. If it does, then we need to invalidate those markers
                    -- detecting whether a deleted range spans the beginning/end of a marker is easy. Just need to check whether the start of the range
                    -- contains the marker, and whether the end contains it. If one does and the other doesn't, then we need to invalidate it.

                    -- to invalidate a marker we can just set a flag on the marker to let us know it's invalid.
                    -- This might seem like avoiding the problem but it's a fairly efficient way of avoiding anything linear
}

fn printTree(n: *Node, indent := 0) {
    if n == nil { return; }

    if indent > 0 {
        for i: iter.until(indent) {
            io.print("  ");
        }
    }

    if n.parent {
        io.println("*");
        printTree(n.children.left, indent + 1);
        printTree(n.children.right, indent + 1);
    }
    else {
        for marker: markers(n)|list.iter!(Marker) {
            io.print({name: marker.name, weight: n.weight});
        }

        puts("\n");
    }
}

fn test() {
    p := makeParent(makeParent(
                        makeChild(list.of!(Marker)({{MarkerType.custom, "f"}}), 8),
                        makeChild(list.of!(Marker)({{MarkerType.custom, "a"}, {MarkerType.custom, "b"}, {MarkerType.custom, "d"}}), 9)),
                    makeParent(
                        makeChild(list.of!(Marker)({{MarkerType.custom, "a"}}), 4),
                        makeChild(list.of!(Marker)({{MarkerType.custom, "a"}, {MarkerType.custom, "c"}, {MarkerType.custom, "e"}}), 8)));

    printTree(p);
    puts(".........\n");

    q := p|insertText(at: 3, len: 1);
    printTree(q);

    io.println("------------");
    io.println("success!");
    io.println("------------");

    return 0;
}
