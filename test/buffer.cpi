#import "mem";

type Buffer(T := typeof(buf[0])) struct {
    capacity: i64,
    buf: []T
}

type BufferIterator struct {
    index: i64,
    buffer: !T/Buffer
}

-- todo(chad): make this a #attr(Buffer)
fn iter(b: !B/Buffer) {
    return cast(BufferIterator) { 0, b };
}

#attr(BufferIterator) {
    fn empty(b: !B/BufferIterator) {
        return b.index >= b.buffer.buf.count;
    }

    fn front(b: !B/BufferIterator) {
        return b.buffer.buf[b.index];
    }

    fn popFront(b: !B/BufferIterator) {
        b.index += 1;
    }
}

fn make(T: Ast)(capacity := 1) {
    buf: []T;
    buf.count = 0;
    buf.data = mem.alloc!(T)(capacity);

    return cast(Buffer!(T)) {
        capacity: capacity,
        buf: buf
    };
}

fn from(T := typeof(t[0]))(t: []T) {
    b := make!(T)(t.count);
    b.buf.count = t.count;
    mem.memcpy(b.buf.data, t.data, t.count * sizeof(T));
    return b;
}

#import "io";

#attr(Buffer) {
fn release(b: !T/Buffer) {
    mem.free(cast() b.buf.data);
}

fn ensureCapacity(b: !T/Buffer, index: i64) {
    if b.capacity == 0 {
        b.capacity = 1;
    }

    type E typeof(b.buf[0])

    while index >= b.capacity {
        b.capacity = b.capacity * 2;

        newBuf: []E;
        newBuf.count = b.buf.count;
        newBuf.data = mem.alloc!(E)(b.capacity);
        mem.memcpy(newBuf.data, b.buf.data, b.buf.count * sizeof(E));
        mem.free(b.buf.data);

        b.buf = newBuf;
    }
}

fn set( T := typeof(^b), E := typeof(b.buf[0]) )(b: *T/Buffer, index: i64, e: E) {
    ensureCapacity(b, index + 1);

    b.buf[index] = e;
    return b.capacity;
}

fn append( T := typeof(^b), E := typeof(b.buf[0]) )(b: *T/Buffer, e: E) {
    set(b, b.buf.count, e);
    b.buf.count += 1;
}

fn appends( T := typeof(^b), E := typeof(b.buf[0]) )(b: *T/Buffer, e: []E) {
    for _e: e {
        append(b, _e);
    }
}

fn get(b: !T/Buffer, index: i64) {
    ensureCapacity(b, index);
    return b.buf[index];
}
}
