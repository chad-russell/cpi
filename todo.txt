TODO:
    - better interpreter debugging
        - more accurate source information, stopping, etc.
        - get list of stack variables and print their values by name
        - implement option to have memory as a rope structure -- infinite undo/redo of program execution state

    - pipe operator

    - libraries / namespaces / modules

    - possibly bring back 'Type' as a way of asserting something must be a type
        - writing 'fn foo(t: Any)() { ... }' is a little weird considering the vast majority of the time we actually just want to accept a type here and not any random ast node

    -- switch
        -- on enum (tag)
        if a == {
            x: {
                return 111;
            }
            y: {
                panic();
            }
            else: {

            }
        }
        -- on other things (??)

    - defer

    - parse symbols in backticks
        - `0n3:s!mb()l` := 3;

    - more integer formats
        - hex (0x123)
        - binary (0b10010011)

    - array bounds checking

    - how to make custom stretchy buffer that's also pretty
        - support a pre-check for opEquals and opEqualsAssign (?)
        - a := buf!(i32)(10); a|append(3); return a|at(1);
        - a := [10]i32{}; a|append(3); return a[1];
        - maybe just get rid of `[]` syntax... instead of giving all types a way to
            access to special syntax, we can just have less special syntax

    - varargs
        - fn print(args: ...) { }
        - e.g. `print("here is a value: ", 3, " and here is another one: ", {x: 13, y: &67}, ". That is all! :)");`
        - implementation -- just pack them all into a struct
