TODO:
    - get all tests passing with llvm again

    - replace 'anyof' with 'typeinfo', and finish implementing buildTypeInfoStructLiteral for struct/fn types

    - support printing

    - better interpreter debugging
        - more accurate source information, stopping, etc.
        - get list of stack variables and print their values by name

    - libraries / namespaces / modules

    - better type matching
        - when are struct types matched nominally vs structurally?
        - when are int/float types auto-converted/promoted?
        - arrays, strings, etc.

    - pipe operator

    - possibly bring back 'Type' as a way of asserting something must be a type
        - writing 'fn foo(t: Any)() { ... }' is a little weird considering the vast majority of the time we actually just want to accept a type here and not any random ast node

    -- switch
        -- on enum (tag)
        switch a {
        case x: {
            ret 111;
        }
        case y: {
            panic();
        }
        case default: {

        }
        }

    - defer

    - signed vs unsigned ints

    - parse symbols in ``
        - `0n3:s!mb()l` := 3;

    - more integer formats
        - hex (0x123)
        - binary (0b10010011)

    - array bounds checking

    - how to make custom stretchy buffer that's also pretty
        - support a pre-check for opEquals and opEqualsAssign (?)
        - a := buf!(i32)(10); a|append(3); ret a|at(1);
        - a := [10]i32{}; a|append(3); ret a[1];
        - maybe just get rid of `[]` syntax... instead of giving all types a way to
            access to special syntax, we can just have less special syntax

    - decide if we want to support inline conversion
        - e.g. 'a := Foo{1, 2, 3}'
        - probably no for now
