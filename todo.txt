TODO:
    - struct literal refactor
        - rewrite as a declaration and then assigments through dots
        - need to be careful when pointers are involved (i.e. taking the address of something inline)
        - should trigger when:
            - decl/assignment combo
            - assignment
            - passing through struct parameters

    - when there is no initialValue on a declaration, the backend should zero the memory

    - merge the concepts of declParam and valueParam. It's too confusing at this point and we are needing to switch between them too often

    - support 'putchar' in interpreter

    - fix buffer test
        - infinite loops in llvm
        - returns 0 everywhere if you try to use pointers... :(

    - replace 'anyof' with 'typeinfo', and finish implementing buildTypeInfoStructLiteral for struct/fn types

    - better interpreter debugging
        - more accurate source information, stopping, etc.
        - get list of stack variables and print their values by name

    - libraries / namespaces / modules

    - better type matching
        - when are struct types matched nominally vs structurally?
        - when are int/float types auto-converted/promoted?
        - arrays, strings, etc.

    - pipe operator

    - possibly bring back 'Type' as a way of asserting something must be a type
        - writing 'fn foo(t: Any)() { ... }' is a little weird considering the vast majority of the time we actually just want to accept a type here and not any random ast node

    -- switch
        -- on enum (tag)
        switch a {
        case x: {
            ret 111;
        }
        case y: {
            panic();
        }
        case default: {

        }
        }

    - defer

    - signed vs unsigned ints

    - parse symbols in ``
        - `0n3:s!mb()l` := 3;

    - more integer formats
        - hex (0x123)
        - binary (0b10010011)

    - array bounds checking

    - how to make custom stretchy buffer that's also pretty
        - support a pre-check for opEquals and opEqualsAssign (?)
        - a := buf!(i32)(10); a|append(3); ret a|at(1);
        - a := [10]i32{}; a|append(3); ret a[1];
        - maybe just get rid of `[]` syntax... instead of giving all types a way to
            access to special syntax, we can just have less special syntax
