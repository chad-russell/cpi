TODO:
    - replace 'anyof' with 'typeinfo', and finish implementing buildTypeInfoStructLiteral for struct/fn types
        - consider

    - merge the concepts of declParam and valueParam. It's too confusing at this point and we are needing to switch between them too often

    - better interpreter debugging
        - more accurate source information, stopping, etc.
        - get list of stack variables and print their values by name
        - implement option to have memory as a rope structure -- infinite undo/redo of program execution state

    - libraries / namespaces / modules

    - better type matching
        - when are struct types matched nominally vs structurally?
        - when are int/float types auto-converted/promoted?
        - arrays, strings, etc.

    - pipe operator

    - possibly bring back 'Type' as a way of asserting something must be a type
        - writing 'fn foo(t: Any)() { ... }' is a little weird considering the vast majority of the time we actually just want to accept a type here and not any random ast node

    -- switch
        -- on enum (tag)
        switch a {
        case x: {
            ret 111;
        }
        case y: {
            panic();
        }
        case default: {

        }
        }

    - defer

    - signed vs unsigned ints

    - parse symbols in backticks
        - `0n3:s!mb()l` := 3;

    - more integer formats
        - hex (0x123)
        - binary (0b10010011)

    - array bounds checking

    - how to make custom stretchy buffer that's also pretty
        - support a pre-check for opEquals and opEqualsAssign (?)
        - a := buf!(i32)(10); a|append(3); ret a|at(1);
        - a := [10]i32{}; a|append(3); ret a[1];
        - maybe just get rid of `[]` syntax... instead of giving all types a way to
            access to special syntax, we can just have less special syntax
