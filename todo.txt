TODO:
    - implement context and passing as implicit parameter
        - remove 'heap' as a concept -- should always just use the context

    - threading
        - for interpreter, should create another interpreter and add it to a list. Execution should round-robin over all interpreters in the list
        - for llvm version, can utilize pthread routines
        - basic:
            - create: ```
                fn foo(i: i32, s: []i8);
                #async foo(3, "a string");
            ```
            - in llvm this should translate to: ```
                pthread_t __t;
                pthread_create(&__t, nil, cast(fn(data: *none) *none) thread_init_foo, cast(*none) &{3, "a string"});
            ```
            - each function which is #async'd needs a custom init function. thread_init_foo should look like: ```
                fn thread_init_foo(data: *{_0: i32, _1: []i8}) {
                    foo(makeContext(), data._0, data._1);
                }
            ```
            - todo(chad): what about calling external functions?
                - in llvm should just work
                - in interpreter, I *think* it should just be a matter of not passing the context in the calling args
            - todo(chad): what about passing parameters?
                - the parameters will have to potentially outlive the scope of the caller
                - should the compiler give an error when this is not the case? or should it just be up to the programmer to know?
            - todo(chad): what about functions which have return values
                - they should probably just get ignored (what else?)
        - advanced:
            - #async should resolve to a thread id. That thread id should also be stored in the context
            - exit current thread
            - join thread with given id

    - better specification of paths for imports
        - path should always be relative to the main file, regardless of where the compiler was run from
        - allow for import paths
            - #importPath "/usr/local/cpi/imports";
            - allow from command line as well (?) (or possibly an environment variable?)

    - specification of paths for lib linking
        - path should always be relative to the main file, regardless of where the compiler was run from
        - example:
            - ```
                #link "foo" {
                    fn bar() i64;
                    fn baz(i: i32) *none;
                }
            ```
        - allow for link paths
            - #linkPath "/usr/local/cpi/lib";
            - allow from command line as well (?) (or possibly an environment variable?)

    - global variables
        - at top-level and module-level
        - need them at the very least for mutexes, but also for global ids, etc. (i.e. if we're making a multi-threaded parser then node_id needs to be globally unique)

    - mutexes
        - ```
            m: mutex; -- global. This should get initialized when the program starts
            #sync(m) {
                -- do stuff. Should lock at the beginning and unlock at the end
            }
        ```

    - more robustness for 'constantize'
        - figure out what things can be constant and what things can't
            - everything but pointers (??)
        - error printing when things aren't supported

    - better interpreter debugging
        - fix all the broken stuff
        - implement option to have memory as a rope structure -- infinite undo/redo of program execution state
            - will need to re-work how this works considering malloc/free escape out of our sandbox
                - might not be an issue once context is a thing, especially considering that anything calling out to C won't work either
            - use this for step/continue backwards in vscode
        - conditional breakpoints
        - ctfe debugging

    - switch (on enum (tag))
        - only real benefit is that the compiler could warn you if you miss a case

    - how to make custom stretchy buffer that's also pretty
        - probably just get rid of `[]` syntax... instead of giving all types a way to
            access to special syntax, can just have less special syntax
        - a := buf!(i32)(10); a|append(3); return a|at(1);
