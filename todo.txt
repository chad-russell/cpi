TODO:
    - how to add user variables to context?

    - support passing args to main fn

    - printing floats

    - support profiling in interpreter

    - build a better debugger backend
        - ability to do eval in the context of a particular stack frame (e.g. eval this 3 frames ago)
        - CT arguments should show up as variables in the inspector
        - ability to set variables (where applicable)
        - support for breakpoints on columns, ranges
        - implement option to have memory as a rope structure -- infinite undo/redo of program execution state
            - will need to transition to always using the context allocator instead of libc malloc/free
            - use this for step/continue backwards in vscode
        - ctfe debugging (?)

    - switch (on enum/union)

    - operator overloading?
        +, -, *, /, comparison

    - ways to deal with nullable/non-nullable pointers (?)
        - .? operator

    - some kind of zig-like error handling (?)

    - better unions (?)
        - @notag attribute on type decl?
        - @tag to specify which field should get used as the tag?

    - static array sizes?
        - [5]i32
        - should this be used to represent string literals?

    - disallow modifying constantized values (i.e. any kind of lvalue assignment) for aliases, ctParams, etc

    - way to specify foreign function names different from given name
        - ```
            #foreign(glfwInit) fn init() bool
        ```

    - threading
        - for interpreter, should create another interpreter and add it to a list. Execution should round-robin over all interpreters in the list
        - for llvm version, can utilize pthread routines
        - basic:
            - create: ```
                fn foo(i: i32, s: []i8);
                #async foo(3, "a string");
            ```
            - in llvm this should translate to: ```
                pthread_t __t;
                pthread_create(&__t, nil, cast(fn(data: *none) *none) thread_init_foo, cast(*none) &{3, "a string"});
            ```
            - each function which is #async'd needs a custom init function. thread_init_foo should look like: ```
                fn thread_init_foo(data: *{_0: i32, _1: []i8}) {
                    foo(makeContext(), data._0, data._1);
                }
            ```
            - todo(chad): what about calling external functions?
                - in llvm should just work
                - in interpreter, I *think* it should just be a matter of not passing the context in the calling args
            - todo(chad): what about passing parameters?
                - the parameters will have to potentially outlive the scope of the caller
                - should the compiler give an error when this is not the case? or should it just be up to the programmer to know?
            - todo(chad): what about functions which have return values
                - they should probably just get ignored (what else?)
        - advanced:
            - #async should resolve to a thread id. That thread id should also be stored in the context
            - exit current thread
            - join thread with given id

    - mutexes
        - ```
            m: mutex; -- global. This should get initialized when the program starts
            #sync(m) {
                -- do stuff. Should lock at the beginning and unlock at the end
            }
        ```

