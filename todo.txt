TODO:
    - merge the concepts of declParam and valueParam. It's too confusing at this point and we are needing to switch between them too often

    - #for (static foreach)
        - array literal
            - #for it: []{1, 2, 3} { ... }
        - struct
            - #for it: {x: 18, y: "foobar"} { ... }
        - example -- printing enums
            - #for i, _: enumValue {
                if t.tag == i {
                    print(cast(#fieldtypeof(T, i)) t.data);
                }
            }
    - #iskind
        - `iskind(a, i32)`, `iskind(b, array)`, `iskind(c, struct)`, `iskind(d, fn)`, etc.
    - #fieldcount
    - #fieldnameof
        - names of struct  -- #fieldnameof(struct {x: i32, y: i64}, 1)
        - names of fn args -- #fieldnameof(fn(x: i32, y: i64) bool, 0)
    - #fieldtypeof
        - struct -- #fieldtypeof(struct {x: f32, y: i64}, 1)
        - fn -- #fieldtypeof(fn(x: f32, y: i64) bool, 0)
    - #rettypeof

    - arbitrary printing
        - e.g. `print("here is a value: ", 3, " and here is another one: ", {x: 13, y: &67}, ". That is all! :)");`
        - will need varargs
            - implementation -- just pack them all into a struct

    - better interpreter debugging
        - more accurate source information, stopping, etc.
        - get list of stack variables and print their values by name
        - implement option to have memory as a rope structure -- infinite undo/redo of program execution state

    - libraries / namespaces / modules

    - better type matching
        - when are struct types matched nominally vs structurally?
        - when are int/float types auto-converted/promoted?
        - arrays, strings, etc.

    - pipe operator

    - possibly bring back 'Type' as a way of asserting something must be a type
        - writing 'fn foo(t: Any)() { ... }' is a little weird considering the vast majority of the time we actually just want to accept a type here and not any random ast node

    -- switch
        -- on enum (tag)
        switch a {
            x: {
                return 111;
            }
            y: {
                panic();
            }
            else: {

            }
        }
        -- on other things (??)

    - defer

    - signed vs unsigned ints

    - parse symbols in backticks
        - `0n3:s!mb()l` := 3;

    - more integer formats
        - hex (0x123)
        - binary (0b10010011)

    - array bounds checking

    - how to make custom stretchy buffer that's also pretty
        - support a pre-check for opEquals and opEqualsAssign (?)
        - a := buf!(i32)(10); a|append(3); return a|at(1);
        - a := [10]i32{}; a|append(3); return a[1];
        - maybe just get rid of `[]` syntax... instead of giving all types a way to
            access to special syntax, we can just have less special syntax
