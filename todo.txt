TODO:
    - libraries / namespaces / modules

    - top-level (module-level?) constants
        - constant counts as anything ctfe-able (constantize)

    - special syntax for auto-compile-time args
        - `fn f(t: !T) { return t; }`
            - short for `fn f(T := typeof(t))(t: T) { return t; }`

    - think about the future of 'heap' -- we probably don't even need it except for arrays
        - how best to specify the default heapifier for arrays? *probably* with implicit parameter passing

    - defer

    - pipe operator

    - better interpreter debugging
        - implement option to have memory as a rope structure -- infinite undo/redo of program execution state
            - use this for step/continue backwards in vscode
        - conditional breakpoints
        - ctfe debugging

    - possibly bring back 'Type' as a way of asserting something must be a type
        - writing 'fn foo(t: Any)() { ... }' is a little weird considering the vast majority of the time we actually just want to accept a type here and not any random ast node

    -- switch
        -- on enum (tag)
        if a == {
            x: {
                return 111;
            }
            y: {
                panic();
            }
            else: {

            }
        }
        -- only real benefit is that the compiler could warn you if you miss a case

    - parse symbols in backticks
        - `0n3:s!mb()l` := 3;

    - more integer formats
        - hex (0x123)
        - binary (0b10010011)

    - array bounds checking

    - how to make custom stretchy buffer that's also pretty
        - probably just get rid of `[]` syntax... instead of giving all types a way to
            access to special syntax, we can just have less special syntax
        - a := buf!(i32)(10); a|append(3); return a|at(1);

    - varargs
        - fn print(args: ...) { }
        - e.g. `print("here is a value: ", 3, " and here is another one: ", {x: 13, y: &67}, ". That is all! :)");`
        - implementation -- just pack them all into a struct
