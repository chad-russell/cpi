TODO:
    - autocast

    - disallow modifying aliases (i.e. any kind of lvalue assignment)

    - character literals

    - something for c-style enums?
        - like a way to specify that our enum has no value

    - do static array sizes make sense?
        - [5]i32

    - way to specify foreign function names different from given name
        - ```
            #foreign("init") fn glfwInit() bool
        ```

    - best way of specifying generic types (returntype/typeof hacks are maybe a little janky)

    - better interpreter debugging
        - support for removing breakpoints
        - when stops on a breakpoint, info should immediately appear instead of only when going to 'next'
        - conditional breakpoints
        - implement option to have memory as a rope structure -- infinite undo/redo of program execution state
            - will need to re-work how this works considering malloc/free escape out of our sandbox
                - might not be an issue once context is a thing, especially considering that anything calling out to C won't work either
            - use this for step/continue backwards in vscode
        - ctfe debugging

    - switch (on enum (tag))
        - only real benefit is that the compiler could warn you if you miss a case

    - test the shit out of it

    - threading
        - for interpreter, should create another interpreter and add it to a list. Execution should round-robin over all interpreters in the list
        - for llvm version, can utilize pthread routines
        - basic:
            - create: ```
                fn foo(i: i32, s: []i8);
                #async foo(3, "a string");
            ```
            - in llvm this should translate to: ```
                pthread_t __t;
                pthread_create(&__t, nil, cast(fn(data: *none) *none) thread_init_foo, cast(*none) &{3, "a string"});
            ```
            - each function which is #async'd needs a custom init function. thread_init_foo should look like: ```
                fn thread_init_foo(data: *{_0: i32, _1: []i8}) {
                    foo(makeContext(), data._0, data._1);
                }
            ```
            - todo(chad): what about calling external functions?
                - in llvm should just work
                - in interpreter, I *think* it should just be a matter of not passing the context in the calling args
            - todo(chad): what about passing parameters?
                - the parameters will have to potentially outlive the scope of the caller
                - should the compiler give an error when this is not the case? or should it just be up to the programmer to know?
            - todo(chad): what about functions which have return values
                - they should probably just get ignored (what else?)
        - advanced:
            - #async should resolve to a thread id. That thread id should also be stored in the context
            - exit current thread
            - join thread with given id

    - mutexes
        - ```
            m: mutex; -- global. This should get initialized when the program starts
            #sync(m) {
                -- do stuff. Should lock at the beginning and unlock at the end
            }
        ```
